# All input for the `authenticateUser` mutation.
input AuthenticateUserInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  phone: String!
}

# The output of our `authenticateUser` mutation.
type AuthenticateUserPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  authenticateUserResult: AuthenticateUserResult

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

type AuthenticateUserResult {
  jwtToken: JwtToken
  userId: UUID
}

# A brand that has or sells food.
type Brand implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # The unique identifier for the brand.
  rowId: UUID!

  # The unique identifier for the user who owns the brand.
  ownerId: UUID

  # The name of the person responsible for the brand listing. This is a fallback for not having a registered user as owner id.
  ownerName: String

  # The brand’s human-readable name.
  name: String!

  # The brand’s primary email address.
  email: String

  # The brand’s phone number.
  phone: String

  # The brand’s external website url.
  url: String

  # The time this object was created.
  createdAt: Datetime

  # The time this object was last updated.
  updatedAt: Datetime

  # Reads a single `User` that is related to this `Brand`.
  userByOwnerId: User

  # Reads and enables pagination through a set of `Food`.
  foodsByBrandName(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `Food`.
    orderBy: FoodsOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: FoodCondition
  ): FoodsConnection!
}

# A condition to be used against `Brand` object types. All fields are tested for equality and combined with a logical ‘and.’
input BrandCondition {
  # Checks for equality with the object’s `rowId` field.
  rowId: UUID

  # Checks for equality with the object’s `ownerId` field.
  ownerId: UUID

  # Checks for equality with the object’s `ownerName` field.
  ownerName: String

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `email` field.
  email: String

  # Checks for equality with the object’s `phone` field.
  phone: String

  # Checks for equality with the object’s `url` field.
  url: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# An input for mutations affecting `Brand`
input BrandInput {
  # The unique identifier for the brand.
  rowId: UUID

  # The unique identifier for the user who owns the brand.
  ownerId: UUID

  # The name of the person responsible for the brand listing. This is a fallback for not having a registered user as owner id.
  ownerName: String

  # The brand’s human-readable name.
  name: String!

  # The brand’s primary email address.
  email: String

  # The brand’s phone number.
  phone: String

  # The brand’s external website url.
  url: String

  # The time this object was created.
  createdAt: Datetime

  # The time this object was last updated.
  updatedAt: Datetime
}

# Represents an update to a `Brand`. Fields that are set will be updated.
input BrandPatch {
  # The unique identifier for the brand.
  rowId: UUID

  # The unique identifier for the user who owns the brand.
  ownerId: UUID

  # The name of the person responsible for the brand listing. This is a fallback for not having a registered user as owner id.
  ownerName: String

  # The brand’s human-readable name.
  name: String

  # The brand’s primary email address.
  email: String

  # The brand’s phone number.
  phone: String

  # The brand’s external website url.
  url: String

  # The time this object was created.
  createdAt: Datetime

  # The time this object was last updated.
  updatedAt: Datetime
}

# A connection to a list of `Brand` values.
type BrandsConnection {
  # A list of `Brand` objects.
  nodes: [Brand]!

  # A list of edges which contains the `Brand` and cursor to aid in pagination.
  edges: [BrandsEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Brand` you could get from the connection.
  totalCount: Int
}

# A `Brand` edge in the connection.
type BrandsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Brand` at the end of the edge.
  node: Brand!
}

# Methods to use when ordering `Brand`.
enum BrandsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  OWNER_ID_ASC
  OWNER_ID_DESC
  OWNER_NAME_ASC
  OWNER_NAME_DESC
  NAME_ASC
  NAME_DESC
  EMAIL_ASC
  EMAIL_DESC
  PHONE_ASC
  PHONE_DESC
  URL_ASC
  URL_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

# A conversation session between a person and the agent.
type Conversation implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # The unique identifier for the conversation which is provided by the agent.
  rowId: UUID!

  # The unique identifier for the person.
  userId: UUID!

  # The time this object was created.
  createdAt: Datetime

  # Reads a single `User` that is related to this `Conversation`.
  userByUserId: User!

  # Reads and enables pagination through a set of `Message`.
  messagesByConversationId(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `Message`.
    orderBy: MessagesOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: MessageCondition
  ): MessagesConnection!
}

# A condition to be used against `Conversation` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input ConversationCondition {
  # Checks for equality with the object’s `rowId` field.
  rowId: UUID

  # Checks for equality with the object’s `userId` field.
  userId: UUID

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime
}

# An input for mutations affecting `Conversation`
input ConversationInput {
  # The unique identifier for the conversation which is provided by the agent.
  rowId: UUID!

  # The unique identifier for the person.
  userId: UUID!

  # The time this object was created.
  createdAt: Datetime
}

# Represents an update to a `Conversation`. Fields that are set will be updated.
input ConversationPatch {
  # The unique identifier for the conversation which is provided by the agent.
  rowId: UUID

  # The unique identifier for the person.
  userId: UUID

  # The time this object was created.
  createdAt: Datetime
}

# A connection to a list of `Conversation` values.
type ConversationsConnection {
  # A list of `Conversation` objects.
  nodes: [Conversation]!

  # A list of edges which contains the `Conversation` and cursor to aid in pagination.
  edges: [ConversationsEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Conversation` you could get from the connection.
  totalCount: Int
}

# A `Conversation` edge in the connection.
type ConversationsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Conversation` at the end of the edge.
  node: Conversation!
}

# Methods to use when ordering `Conversation`.
enum ConversationsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

# All input for the create `Brand` mutation.
input CreateBrandInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Brand` to be created by this mutation.
  brand: BrandInput!
}

# The output of our create `Brand` mutation.
type CreateBrandPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Brand` that was created by this mutation.
  brand: Brand

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `User` that is related to this `Brand`.
  userByOwnerId: User

  # An edge for the type. May be used by Relay 1.
  brandEdge(
    # The method to use when ordering `Brand`.
    orderBy: BrandsOrderBy = PRIMARY_KEY_ASC
  ): BrandsEdge
}

# All input for the create `Conversation` mutation.
input CreateConversationInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Conversation` to be created by this mutation.
  conversation: ConversationInput!
}

# The output of our create `Conversation` mutation.
type CreateConversationPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Conversation` that was created by this mutation.
  conversation: Conversation

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `User` that is related to this `Conversation`.
  userByUserId: User

  # An edge for the type. May be used by Relay 1.
  conversationEdge(
    # The method to use when ordering `Conversation`.
    orderBy: ConversationsOrderBy = PRIMARY_KEY_ASC
  ): ConversationsEdge
}

# All input for the create `FoodGroup` mutation.
input CreateFoodGroupInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `FoodGroup` to be created by this mutation.
  foodGroup: FoodGroupInput!
}

# The output of our create `FoodGroup` mutation.
type CreateFoodGroupPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `FoodGroup` that was created by this mutation.
  foodGroup: FoodGroup

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # An edge for the type. May be used by Relay 1.
  foodGroupEdge(
    # The method to use when ordering `FoodGroup`.
    orderBy: FoodGroupsOrderBy = PRIMARY_KEY_ASC
  ): FoodGroupsEdge
}

# All input for the create `Food` mutation.
input CreateFoodInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Food` to be created by this mutation.
  food: FoodInput!
}

# All input for the create `FoodNutrient` mutation.
input CreateFoodNutrientInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `FoodNutrient` to be created by this mutation.
  foodNutrient: FoodNutrientInput!
}

# The output of our create `FoodNutrient` mutation.
type CreateFoodNutrientPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `FoodNutrient` that was created by this mutation.
  foodNutrient: FoodNutrient

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Food` that is related to this `FoodNutrient`.
  foodByFoodId: Food

  # Reads a single `Nutrient` that is related to this `FoodNutrient`.
  nutrientByNutrientId: Nutrient

  # Reads a single `User` that is related to this `FoodNutrient`.
  userByUserId: User

  # An edge for the type. May be used by Relay 1.
  foodNutrientEdge(
    # The method to use when ordering `FoodNutrient`.
    orderBy: FoodNutrientsOrderBy = PRIMARY_KEY_ASC
  ): FoodNutrientsEdge
}

# The output of our create `Food` mutation.
type CreateFoodPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Food` that was created by this mutation.
  food: Food

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `FoodGroup` that is related to this `Food`.
  foodGroupByFoodGroupId: FoodGroup

  # Reads a single `Brand` that is related to this `Food`.
  brandByBrandName: Brand

  # Reads a single `User` that is related to this `Food`.
  userByUserId: User

  # An edge for the type. May be used by Relay 1.
  foodEdge(
    # The method to use when ordering `Food`.
    orderBy: FoodsOrderBy = PRIMARY_KEY_ASC
  ): FoodsEdge
}

# All input for the create `FoodSelection` mutation.
input CreateFoodSelectionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `FoodSelection` to be created by this mutation.
  foodSelection: FoodSelectionInput!
}

# The output of our create `FoodSelection` mutation.
type CreateFoodSelectionPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `FoodSelection` that was created by this mutation.
  foodSelection: FoodSelection

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `User` that is related to this `FoodSelection`.
  userByUserId: User

  # Reads a single `Message` that is related to this `FoodSelection`.
  messageByMessageId: Message

  # Reads a single `Preset` that is related to this `FoodSelection`.
  presetByInheritsFromId: Preset

  # Reads a single `Food` that is related to this `FoodSelection`.
  foodByFoodId: Food

  # Reads a single `UnitOfMeasure` that is related to this `FoodSelection`.
  unitOfMeasureByUnitOfMeasureId: UnitOfMeasure

  # An edge for the type. May be used by Relay 1.
  foodSelectionEdge(
    # The method to use when ordering `FoodSelection`.
    orderBy: FoodSelectionsOrderBy = PRIMARY_KEY_ASC
  ): FoodSelectionsEdge
}

# All input for the create `MassConversion` mutation.
input CreateMassConversionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `MassConversion` to be created by this mutation.
  massConversion: MassConversionInput!
}

# The output of our create `MassConversion` mutation.
type CreateMassConversionPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `MassConversion` that was created by this mutation.
  massConversion: MassConversion

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Food` that is related to this `MassConversion`.
  foodByFoodId: Food

  # Reads a single `UnitOfMeasure` that is related to this `MassConversion`.
  unitOfMeasureByUnitOfMeasureId: UnitOfMeasure

  # Reads a single `User` that is related to this `MassConversion`.
  userByUserId: User

  # An edge for the type. May be used by Relay 1.
  massConversionEdge(
    # The method to use when ordering `MassConversion`.
    orderBy: MassConversionsOrderBy = PRIMARY_KEY_ASC
  ): MassConversionsEdge
}

# All input for the create `Message` mutation.
input CreateMessageInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Message` to be created by this mutation.
  message: MessageInput!
}

# The output of our create `Message` mutation.
type CreateMessagePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Message` that was created by this mutation.
  message: Message

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Conversation` that is related to this `Message`.
  conversationByConversationId: Conversation

  # An edge for the type. May be used by Relay 1.
  messageEdge(
    # The method to use when ordering `Message`.
    orderBy: MessagesOrderBy = PRIMARY_KEY_ASC
  ): MessagesEdge
}

# All input for the create `Nutrient` mutation.
input CreateNutrientInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Nutrient` to be created by this mutation.
  nutrient: NutrientInput!
}

# The output of our create `Nutrient` mutation.
type CreateNutrientPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Nutrient` that was created by this mutation.
  nutrient: Nutrient

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `UnitOfMeasure` that is related to this `Nutrient`.
  unitOfMeasureByUnitOfMeasureUsdaKey: UnitOfMeasure

  # An edge for the type. May be used by Relay 1.
  nutrientEdge(
    # The method to use when ordering `Nutrient`.
    orderBy: NutrientsOrderBy = PRIMARY_KEY_ASC
  ): NutrientsEdge
}

# All input for the create `Place` mutation.
input CreatePlaceInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Place` to be created by this mutation.
  place: PlaceInput!
}

# The output of our create `Place` mutation.
type CreatePlacePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Place` that was created by this mutation.
  place: Place

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `User` that is related to this `Place`.
  userByOwnerId: User

  # An edge for the type. May be used by Relay 1.
  placeEdge(
    # The method to use when ordering `Place`.
    orderBy: PlacesOrderBy = PRIMARY_KEY_ASC
  ): PlacesEdge
}

# All input for the create `Preset` mutation.
input CreatePresetInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Preset` to be created by this mutation.
  preset: PresetInput!
}

# The output of our create `Preset` mutation.
type CreatePresetPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Preset` that was created by this mutation.
  preset: Preset

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `User` that is related to this `Preset`.
  userByUserId: User

  # Reads a single `Message` that is related to this `Preset`.
  messageByMessageId: Message

  # An edge for the type. May be used by Relay 1.
  presetEdge(
    # The method to use when ordering `Preset`.
    orderBy: PresetsOrderBy = PRIMARY_KEY_ASC
  ): PresetsEdge
}

# All input for the create `PresetSelection` mutation.
input CreatePresetSelectionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `PresetSelection` to be created by this mutation.
  presetSelection: PresetSelectionInput!
}

# The output of our create `PresetSelection` mutation.
type CreatePresetSelectionPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `PresetSelection` that was created by this mutation.
  presetSelection: PresetSelection

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Preset` that is related to this `PresetSelection`.
  presetByPresetId: Preset

  # Reads a single `FoodSelection` that is related to this `PresetSelection`.
  foodSelectionBySelectionId: FoodSelection

  # An edge for the type. May be used by Relay 1.
  presetSelectionEdge(
    # The method to use when ordering `PresetSelection`.
    orderBy: PresetSelectionsOrderBy = PRIMARY_KEY_ASC
  ): PresetSelectionsEdge
}

# All input for the create `UnitOfMeasure` mutation.
input CreateUnitOfMeasureInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `UnitOfMeasure` to be created by this mutation.
  unitOfMeasure: UnitOfMeasureInput!
}

# The output of our create `UnitOfMeasure` mutation.
type CreateUnitOfMeasurePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `UnitOfMeasure` that was created by this mutation.
  unitOfMeasure: UnitOfMeasure

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `UnitOfMeasure` that is related to this `UnitOfMeasure`.
  unitOfMeasureByShortNameRef: UnitOfMeasure

  # An edge for the type. May be used by Relay 1.
  unitOfMeasureEdge(
    # The method to use when ordering `UnitOfMeasure`.
    orderBy: UnitOfMeasuresOrderBy = PRIMARY_KEY_ASC
  ): UnitOfMeasuresEdge
}

# All input for the create `User` mutation.
input CreateUserInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `User` to be created by this mutation.
  user: UserInput!
}

# The output of our create `User` mutation.
type CreateUserPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `User` that was created by this mutation.
  user: User

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # An edge for the type. May be used by Relay 1.
  userEdge(
    # The method to use when ordering `User`.
    orderBy: UsersOrderBy = PRIMARY_KEY_ASC
  ): UsersEdge
}

# A location in a connection that can be used for resuming pagination.
scalar Cursor

# The day, does not include a time.
scalar Date

# A point in time as described by the [ISO
# 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
scalar Datetime

# All input for the `deleteBrandByEmail` mutation.
input DeleteBrandByEmailInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  email: String!
}

# All input for the `deleteBrandByName` mutation.
input DeleteBrandByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  name: String!
}

# All input for the `deleteBrandByPhone` mutation.
input DeleteBrandByPhoneInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  phone: String!
}

# All input for the `deleteBrandByRowId` mutation.
input DeleteBrandByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  rowId: UUID!
}

# All input for the `deleteBrand` mutation.
input DeleteBrandInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Brand` to be deleted.
  id: ID!
}

# The output of our delete `Brand` mutation.
type DeleteBrandPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Brand` that was deleted by this mutation.
  brand: Brand
  deletedBrandId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `User` that is related to this `Brand`.
  userByOwnerId: User

  # An edge for the type. May be used by Relay 1.
  brandEdge(
    # The method to use when ordering `Brand`.
    orderBy: BrandsOrderBy = PRIMARY_KEY_ASC
  ): BrandsEdge
}

# All input for the `deleteConversationByRowId` mutation.
input DeleteConversationByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  rowId: UUID!
}

# All input for the `deleteConversation` mutation.
input DeleteConversationInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Conversation` to be deleted.
  id: ID!
}

# The output of our delete `Conversation` mutation.
type DeleteConversationPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Conversation` that was deleted by this mutation.
  conversation: Conversation
  deletedConversationId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `User` that is related to this `Conversation`.
  userByUserId: User

  # An edge for the type. May be used by Relay 1.
  conversationEdge(
    # The method to use when ordering `Conversation`.
    orderBy: ConversationsOrderBy = PRIMARY_KEY_ASC
  ): ConversationsEdge
}

# All input for the `deleteFoodByRowId` mutation.
input DeleteFoodByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  rowId: Float!
}

# All input for the `deleteFoodGroupByRowId` mutation.
input DeleteFoodGroupByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  rowId: Float!
}

# All input for the `deleteFoodGroup` mutation.
input DeleteFoodGroupInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `FoodGroup` to be deleted.
  id: ID!
}

# The output of our delete `FoodGroup` mutation.
type DeleteFoodGroupPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `FoodGroup` that was deleted by this mutation.
  foodGroup: FoodGroup
  deletedFoodGroupId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # An edge for the type. May be used by Relay 1.
  foodGroupEdge(
    # The method to use when ordering `FoodGroup`.
    orderBy: FoodGroupsOrderBy = PRIMARY_KEY_ASC
  ): FoodGroupsEdge
}

# All input for the `deleteFood` mutation.
input DeleteFoodInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Food` to be deleted.
  id: ID!
}

# All input for the `deleteFoodNutrientByFoodIdAndNutrientId` mutation.
input DeleteFoodNutrientByFoodIdAndNutrientIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  foodId: Float!
  nutrientId: Float!
}

# All input for the `deleteFoodNutrient` mutation.
input DeleteFoodNutrientInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `FoodNutrient` to be deleted.
  id: ID!
}

# The output of our delete `FoodNutrient` mutation.
type DeleteFoodNutrientPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `FoodNutrient` that was deleted by this mutation.
  foodNutrient: FoodNutrient
  deletedFoodNutrientId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Food` that is related to this `FoodNutrient`.
  foodByFoodId: Food

  # Reads a single `Nutrient` that is related to this `FoodNutrient`.
  nutrientByNutrientId: Nutrient

  # Reads a single `User` that is related to this `FoodNutrient`.
  userByUserId: User

  # An edge for the type. May be used by Relay 1.
  foodNutrientEdge(
    # The method to use when ordering `FoodNutrient`.
    orderBy: FoodNutrientsOrderBy = PRIMARY_KEY_ASC
  ): FoodNutrientsEdge
}

# The output of our delete `Food` mutation.
type DeleteFoodPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Food` that was deleted by this mutation.
  food: Food
  deletedFoodId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `FoodGroup` that is related to this `Food`.
  foodGroupByFoodGroupId: FoodGroup

  # Reads a single `Brand` that is related to this `Food`.
  brandByBrandName: Brand

  # Reads a single `User` that is related to this `Food`.
  userByUserId: User

  # An edge for the type. May be used by Relay 1.
  foodEdge(
    # The method to use when ordering `Food`.
    orderBy: FoodsOrderBy = PRIMARY_KEY_ASC
  ): FoodsEdge
}

# All input for the `deleteFoodSelectionByRowId` mutation.
input DeleteFoodSelectionByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  rowId: UUID!
}

# All input for the `deleteFoodSelection` mutation.
input DeleteFoodSelectionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `FoodSelection` to be deleted.
  id: ID!
}

# The output of our delete `FoodSelection` mutation.
type DeleteFoodSelectionPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `FoodSelection` that was deleted by this mutation.
  foodSelection: FoodSelection
  deletedFoodSelectionId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `User` that is related to this `FoodSelection`.
  userByUserId: User

  # Reads a single `Message` that is related to this `FoodSelection`.
  messageByMessageId: Message

  # Reads a single `Preset` that is related to this `FoodSelection`.
  presetByInheritsFromId: Preset

  # Reads a single `Food` that is related to this `FoodSelection`.
  foodByFoodId: Food

  # Reads a single `UnitOfMeasure` that is related to this `FoodSelection`.
  unitOfMeasureByUnitOfMeasureId: UnitOfMeasure

  # An edge for the type. May be used by Relay 1.
  foodSelectionEdge(
    # The method to use when ordering `FoodSelection`.
    orderBy: FoodSelectionsOrderBy = PRIMARY_KEY_ASC
  ): FoodSelectionsEdge
}

# All input for the `deleteMassConversionByFoodIdAndUnitOfMeasureIdAndPhysicalModDescription` mutation.
input DeleteMassConversionByFoodIdAndUnitOfMeasureIdAndPhysicalModDescriptionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  foodId: Float!
  unitOfMeasureId: Int!
  physicalModDescription: String!
}

# All input for the `deleteMassConversionByRowId` mutation.
input DeleteMassConversionByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  rowId: Int!
}

# All input for the `deleteMassConversion` mutation.
input DeleteMassConversionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `MassConversion` to be deleted.
  id: ID!
}

# The output of our delete `MassConversion` mutation.
type DeleteMassConversionPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `MassConversion` that was deleted by this mutation.
  massConversion: MassConversion
  deletedMassConversionId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Food` that is related to this `MassConversion`.
  foodByFoodId: Food

  # Reads a single `UnitOfMeasure` that is related to this `MassConversion`.
  unitOfMeasureByUnitOfMeasureId: UnitOfMeasure

  # Reads a single `User` that is related to this `MassConversion`.
  userByUserId: User

  # An edge for the type. May be used by Relay 1.
  massConversionEdge(
    # The method to use when ordering `MassConversion`.
    orderBy: MassConversionsOrderBy = PRIMARY_KEY_ASC
  ): MassConversionsEdge
}

# All input for the `deleteMessageByRowId` mutation.
input DeleteMessageByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  rowId: UUID!
}

# All input for the `deleteMessage` mutation.
input DeleteMessageInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Message` to be deleted.
  id: ID!
}

# The output of our delete `Message` mutation.
type DeleteMessagePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Message` that was deleted by this mutation.
  message: Message
  deletedMessageId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Conversation` that is related to this `Message`.
  conversationByConversationId: Conversation

  # An edge for the type. May be used by Relay 1.
  messageEdge(
    # The method to use when ordering `Message`.
    orderBy: MessagesOrderBy = PRIMARY_KEY_ASC
  ): MessagesEdge
}

# All input for the `deleteNutrientByRowId` mutation.
input DeleteNutrientByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  rowId: Float!
}

# All input for the `deleteNutrient` mutation.
input DeleteNutrientInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Nutrient` to be deleted.
  id: ID!
}

# The output of our delete `Nutrient` mutation.
type DeleteNutrientPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Nutrient` that was deleted by this mutation.
  nutrient: Nutrient
  deletedNutrientId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `UnitOfMeasure` that is related to this `Nutrient`.
  unitOfMeasureByUnitOfMeasureUsdaKey: UnitOfMeasure

  # An edge for the type. May be used by Relay 1.
  nutrientEdge(
    # The method to use when ordering `Nutrient`.
    orderBy: NutrientsOrderBy = PRIMARY_KEY_ASC
  ): NutrientsEdge
}

# All input for the `deletePlaceByName` mutation.
input DeletePlaceByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  name: String!
}

# All input for the `deletePlaceByRowId` mutation.
input DeletePlaceByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  rowId: UUID!
}

# All input for the `deletePlace` mutation.
input DeletePlaceInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Place` to be deleted.
  id: ID!
}

# The output of our delete `Place` mutation.
type DeletePlacePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Place` that was deleted by this mutation.
  place: Place
  deletedPlaceId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `User` that is related to this `Place`.
  userByOwnerId: User

  # An edge for the type. May be used by Relay 1.
  placeEdge(
    # The method to use when ordering `Place`.
    orderBy: PlacesOrderBy = PRIMARY_KEY_ASC
  ): PlacesEdge
}

# All input for the `deletePresetByRowId` mutation.
input DeletePresetByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  rowId: UUID!
}

# All input for the `deletePresetByUserIdAndName` mutation.
input DeletePresetByUserIdAndNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  userId: UUID!
  name: String!
}

# All input for the `deletePreset` mutation.
input DeletePresetInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Preset` to be deleted.
  id: ID!
}

# The output of our delete `Preset` mutation.
type DeletePresetPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Preset` that was deleted by this mutation.
  preset: Preset
  deletedPresetId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `User` that is related to this `Preset`.
  userByUserId: User

  # Reads a single `Message` that is related to this `Preset`.
  messageByMessageId: Message

  # An edge for the type. May be used by Relay 1.
  presetEdge(
    # The method to use when ordering `Preset`.
    orderBy: PresetsOrderBy = PRIMARY_KEY_ASC
  ): PresetsEdge
}

# All input for the `deletePresetSelectionByPresetIdAndSelectionId` mutation.
input DeletePresetSelectionByPresetIdAndSelectionIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  presetId: UUID!
  selectionId: UUID!
}

# All input for the `deletePresetSelection` mutation.
input DeletePresetSelectionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `PresetSelection` to be deleted.
  id: ID!
}

# The output of our delete `PresetSelection` mutation.
type DeletePresetSelectionPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `PresetSelection` that was deleted by this mutation.
  presetSelection: PresetSelection
  deletedPresetSelectionId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Preset` that is related to this `PresetSelection`.
  presetByPresetId: Preset

  # Reads a single `FoodSelection` that is related to this `PresetSelection`.
  foodSelectionBySelectionId: FoodSelection

  # An edge for the type. May be used by Relay 1.
  presetSelectionEdge(
    # The method to use when ordering `PresetSelection`.
    orderBy: PresetSelectionsOrderBy = PRIMARY_KEY_ASC
  ): PresetSelectionsEdge
}

# All input for the `deleteUnitOfMeasureByFullName` mutation.
input DeleteUnitOfMeasureByFullNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  fullName: String!
}

# All input for the `deleteUnitOfMeasureByRowId` mutation.
input DeleteUnitOfMeasureByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  rowId: Int!
}

# All input for the `deleteUnitOfMeasureByShortName` mutation.
input DeleteUnitOfMeasureByShortNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  shortName: String!
}

# All input for the `deleteUnitOfMeasureByUsdaKey` mutation.
input DeleteUnitOfMeasureByUsdaKeyInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  usdaKey: String!
}

# All input for the `deleteUnitOfMeasure` mutation.
input DeleteUnitOfMeasureInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `UnitOfMeasure` to be deleted.
  id: ID!
}

# The output of our delete `UnitOfMeasure` mutation.
type DeleteUnitOfMeasurePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `UnitOfMeasure` that was deleted by this mutation.
  unitOfMeasure: UnitOfMeasure
  deletedUnitOfMeasureId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `UnitOfMeasure` that is related to this `UnitOfMeasure`.
  unitOfMeasureByShortNameRef: UnitOfMeasure

  # An edge for the type. May be used by Relay 1.
  unitOfMeasureEdge(
    # The method to use when ordering `UnitOfMeasure`.
    orderBy: UnitOfMeasuresOrderBy = PRIMARY_KEY_ASC
  ): UnitOfMeasuresEdge
}

# All input for the `deleteUserByPhone` mutation.
input DeleteUserByPhoneInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  phone: String!
}

# All input for the `deleteUserByRowId` mutation.
input DeleteUserByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  rowId: UUID!
}

# All input for the `deleteUser` mutation.
input DeleteUserInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `User` to be deleted.
  id: ID!
}

# The output of our delete `User` mutation.
type DeleteUserPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `User` that was deleted by this mutation.
  user: User
  deletedUserId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # An edge for the type. May be used by Relay 1.
  userEdge(
    # The method to use when ordering `User`.
    orderBy: UsersOrderBy = PRIMARY_KEY_ASC
  ): UsersEdge
}

# Contains all food items from the USDA Nutrient Databank Standard Reference 28
type Food implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # 5-digit or 8-digit Nutrient Databank number that uniquely identifies a food item.
  rowId: Float!

  # 4-digit code indicating food group to which a food item belongs.
  foodGroupId: Float

  # Indicates the company that manufactured the product, when appropriate.
  brandName: String

  # 200-character description of food item.
  description: String!

  # Description of inedible parts of a food item (refuse), such as seeds or bone.
  refuseDescription: String

  # Percentage of refuse.
  refuse: Float

  # Factor for calculating calories from protein.
  proteinFactor: Float

  # Factor for calculating calories from fat.
  fatFactor: Float

  # Factor for calculating calories from carbohydrate.
  carbFactor: Float
  source: InputSource

  # The unique identifier for the user who created the food.
  userId: UUID

  # Water (g/100g)
  water: Float

  # Food energy (kcal/100g)
  calories: Float

  # Protein (g/100g)
  protein: Float

  # Total lipid (fat) (g/100g)
  fat: Float

  # Ash (g/100g)
  ash: Float

  # Carbohydrate, by difference (g/100g)
  carbs: Float

  # Total dietary fiber (g/100g)
  fiber: Float

  # Total sugars (g/100g)
  sugar: Float

  # Calcium (mg/100g)
  calcium: Float

  # Iron (mg/100g)
  iron: Float

  # Magnesium (mg/100g)
  magnesium: Float

  # Phosphorus (mg/100g)
  phosphorus: Float

  # Potassium (mg/100g)
  potassium: Float

  # Sodium (mg/100g)
  sodium: Float

  # Zinc (mg/100g)
  zinc: Float

  # Copper (mg/100g)
  copper: Float

  # Manganese (mg/100g)
  manganese: Float

  # Selenium (μg/100g)
  selenium: Float

  # Vitamin C (mg/100g)
  vitaminC: Float

  # Thiamin (mg/100g)
  thiamin: Float

  # Riboflavin (mg/100g)
  riboflavin: Float

  # Niacin (mg/100g)
  niacin: Float

  # Pantothenic acid (mg/100g)
  pantoAcid: Float

  # Vitamin B6 (mg/100g)
  vitaminB6: Float

  # Folate, total (μg/100g)
  folate: Float

  # Folic acid (μg/100g)
  folicAcid: Float

  # Food folate (μg/100g)
  foodFolate: Float

  # Folate (μg dietary folate equivalents/100g)
  folateDfe: Float

  # Choline, total (mg/100g)
  choline: Float

  # Vitamin B12 (μg/100g)
  vitaminB12: Float

  # Vitamin A (IU/100g)
  vitaminAIu: Float

  # Vitamin A (μg retinol activity equivalents/100g)
  vitaminARae: Float

  # Retinol (μg/100g)
  retinol: Float

  # Alpha-carotene (μg/100g)
  alphaCarot: Float

  # Beta-carotene (μg/100g)
  betaCarot: Float

  # Beta-cryptoxanthin (μg/100g)
  betaCrypt: Float

  # Lycopene (μg/100g)
  lycopene: Float

  # Lutein+zeazanthin (μg/100g)
  lutZea: Float

  # Vitamin E (alpha-tocopherol) (mg/100g)
  vitaminE: Float

  # Vitamin D (μg/100g)
  vitaminDMcg: Float

  # Vitamin D (IU/100g)
  vitaminDIu: Float

  # Vitamin K (phylloquinone) (μg/100g)
  vitaminK: Float

  # Saturated fatty acid (g/100g)
  fatSat: Float

  # Monounsaturated fatty acids (g/100g)
  fatMono: Float

  # Polyunsaturated fatty acids (g/100g)
  fatPoly: Float

  # Cholesterol (mg/100g)
  cholesterol: Float

  # The time this object was created.
  createdAt: Datetime

  # The time this object was last updated.
  updatedAt: Datetime

  # Reads a single `FoodGroup` that is related to this `Food`.
  foodGroupByFoodGroupId: FoodGroup

  # Reads a single `Brand` that is related to this `Food`.
  brandByBrandName: Brand

  # Reads a single `User` that is related to this `Food`.
  userByUserId: User

  # Reads and enables pagination through a set of `FoodSelection`.
  foodSelectionsByFoodId(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `FoodSelection`.
    orderBy: FoodSelectionsOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: FoodSelectionCondition
  ): FoodSelectionsConnection!

  # Reads and enables pagination through a set of `MassConversion`.
  massConversionsByFoodId(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `MassConversion`.
    orderBy: MassConversionsOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: MassConversionCondition
  ): MassConversionsConnection!

  # Reads and enables pagination through a set of `FoodNutrient`.
  foodNutrientsByFoodId(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `FoodNutrient`.
    orderBy: FoodNutrientsOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: FoodNutrientCondition
  ): FoodNutrientsConnection!
}

# A condition to be used against `Food` object types. All fields are tested for equality and combined with a logical ‘and.’
input FoodCondition {
  # Checks for equality with the object’s `rowId` field.
  rowId: Float

  # Checks for equality with the object’s `foodGroupId` field.
  foodGroupId: Float

  # Checks for equality with the object’s `brandName` field.
  brandName: String

  # Checks for equality with the object’s `description` field.
  description: String

  # Checks for equality with the object’s `refuseDescription` field.
  refuseDescription: String

  # Checks for equality with the object’s `refuse` field.
  refuse: Float

  # Checks for equality with the object’s `proteinFactor` field.
  proteinFactor: Float

  # Checks for equality with the object’s `fatFactor` field.
  fatFactor: Float

  # Checks for equality with the object’s `carbFactor` field.
  carbFactor: Float

  # Checks for equality with the object’s `source` field.
  source: InputSource

  # Checks for equality with the object’s `userId` field.
  userId: UUID

  # Checks for equality with the object’s `water` field.
  water: Float

  # Checks for equality with the object’s `calories` field.
  calories: Float

  # Checks for equality with the object’s `protein` field.
  protein: Float

  # Checks for equality with the object’s `fat` field.
  fat: Float

  # Checks for equality with the object’s `ash` field.
  ash: Float

  # Checks for equality with the object’s `carbs` field.
  carbs: Float

  # Checks for equality with the object’s `fiber` field.
  fiber: Float

  # Checks for equality with the object’s `sugar` field.
  sugar: Float

  # Checks for equality with the object’s `calcium` field.
  calcium: Float

  # Checks for equality with the object’s `iron` field.
  iron: Float

  # Checks for equality with the object’s `magnesium` field.
  magnesium: Float

  # Checks for equality with the object’s `phosphorus` field.
  phosphorus: Float

  # Checks for equality with the object’s `potassium` field.
  potassium: Float

  # Checks for equality with the object’s `sodium` field.
  sodium: Float

  # Checks for equality with the object’s `zinc` field.
  zinc: Float

  # Checks for equality with the object’s `copper` field.
  copper: Float

  # Checks for equality with the object’s `manganese` field.
  manganese: Float

  # Checks for equality with the object’s `selenium` field.
  selenium: Float

  # Checks for equality with the object’s `vitaminC` field.
  vitaminC: Float

  # Checks for equality with the object’s `thiamin` field.
  thiamin: Float

  # Checks for equality with the object’s `riboflavin` field.
  riboflavin: Float

  # Checks for equality with the object’s `niacin` field.
  niacin: Float

  # Checks for equality with the object’s `pantoAcid` field.
  pantoAcid: Float

  # Checks for equality with the object’s `vitaminB6` field.
  vitaminB6: Float

  # Checks for equality with the object’s `folate` field.
  folate: Float

  # Checks for equality with the object’s `folicAcid` field.
  folicAcid: Float

  # Checks for equality with the object’s `foodFolate` field.
  foodFolate: Float

  # Checks for equality with the object’s `folateDfe` field.
  folateDfe: Float

  # Checks for equality with the object’s `choline` field.
  choline: Float

  # Checks for equality with the object’s `vitaminB12` field.
  vitaminB12: Float

  # Checks for equality with the object’s `vitaminAIu` field.
  vitaminAIu: Float

  # Checks for equality with the object’s `vitaminARae` field.
  vitaminARae: Float

  # Checks for equality with the object’s `retinol` field.
  retinol: Float

  # Checks for equality with the object’s `alphaCarot` field.
  alphaCarot: Float

  # Checks for equality with the object’s `betaCarot` field.
  betaCarot: Float

  # Checks for equality with the object’s `betaCrypt` field.
  betaCrypt: Float

  # Checks for equality with the object’s `lycopene` field.
  lycopene: Float

  # Checks for equality with the object’s `lutZea` field.
  lutZea: Float

  # Checks for equality with the object’s `vitaminE` field.
  vitaminE: Float

  # Checks for equality with the object’s `vitaminDMcg` field.
  vitaminDMcg: Float

  # Checks for equality with the object’s `vitaminDIu` field.
  vitaminDIu: Float

  # Checks for equality with the object’s `vitaminK` field.
  vitaminK: Float

  # Checks for equality with the object’s `fatSat` field.
  fatSat: Float

  # Checks for equality with the object’s `fatMono` field.
  fatMono: Float

  # Checks for equality with the object’s `fatPoly` field.
  fatPoly: Float

  # Checks for equality with the object’s `cholesterol` field.
  cholesterol: Float

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# A support table to the food table that contains a list of food groups used in SR28 and their descriptions.
type FoodGroup implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # 4-digit code identifying a food group. Only the first 2 digits are currently assigned.
  rowId: Float!

  # The name of the food group.
  name: String!

  # Reads and enables pagination through a set of `Food`.
  foodsByFoodGroupId(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `Food`.
    orderBy: FoodsOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: FoodCondition
  ): FoodsConnection!
}

# A condition to be used against `FoodGroup` object types. All fields are tested
# for equality and combined with a logical ‘and.’
input FoodGroupCondition {
  # Checks for equality with the object’s `rowId` field.
  rowId: Float

  # Checks for equality with the object’s `name` field.
  name: String
}

# An input for mutations affecting `FoodGroup`
input FoodGroupInput {
  # 4-digit code identifying a food group. Only the first 2 digits are currently assigned.
  rowId: Float!

  # The name of the food group.
  name: String!
}

# Represents an update to a `FoodGroup`. Fields that are set will be updated.
input FoodGroupPatch {
  # 4-digit code identifying a food group. Only the first 2 digits are currently assigned.
  rowId: Float

  # The name of the food group.
  name: String
}

# A connection to a list of `FoodGroup` values.
type FoodGroupsConnection {
  # A list of `FoodGroup` objects.
  nodes: [FoodGroup]!

  # A list of edges which contains the `FoodGroup` and cursor to aid in pagination.
  edges: [FoodGroupsEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `FoodGroup` you could get from the connection.
  totalCount: Int
}

# A `FoodGroup` edge in the connection.
type FoodGroupsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `FoodGroup` at the end of the edge.
  node: FoodGroup!
}

# Methods to use when ordering `FoodGroup`.
enum FoodGroupsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

# An input for mutations affecting `Food`
input FoodInput {
  # 5-digit or 8-digit Nutrient Databank number that uniquely identifies a food item.
  rowId: Float!

  # 4-digit code indicating food group to which a food item belongs.
  foodGroupId: Float

  # Indicates the company that manufactured the product, when appropriate.
  brandName: String

  # 200-character description of food item.
  description: String!

  # Description of inedible parts of a food item (refuse), such as seeds or bone.
  refuseDescription: String

  # Percentage of refuse.
  refuse: Float

  # Factor for calculating calories from protein.
  proteinFactor: Float

  # Factor for calculating calories from fat.
  fatFactor: Float

  # Factor for calculating calories from carbohydrate.
  carbFactor: Float
  source: InputSource

  # The unique identifier for the user who created the food.
  userId: UUID

  # Water (g/100g)
  water: Float

  # Food energy (kcal/100g)
  calories: Float

  # Protein (g/100g)
  protein: Float

  # Total lipid (fat) (g/100g)
  fat: Float

  # Ash (g/100g)
  ash: Float

  # Carbohydrate, by difference (g/100g)
  carbs: Float

  # Total dietary fiber (g/100g)
  fiber: Float

  # Total sugars (g/100g)
  sugar: Float

  # Calcium (mg/100g)
  calcium: Float

  # Iron (mg/100g)
  iron: Float

  # Magnesium (mg/100g)
  magnesium: Float

  # Phosphorus (mg/100g)
  phosphorus: Float

  # Potassium (mg/100g)
  potassium: Float

  # Sodium (mg/100g)
  sodium: Float

  # Zinc (mg/100g)
  zinc: Float

  # Copper (mg/100g)
  copper: Float

  # Manganese (mg/100g)
  manganese: Float

  # Selenium (μg/100g)
  selenium: Float

  # Vitamin C (mg/100g)
  vitaminC: Float

  # Thiamin (mg/100g)
  thiamin: Float

  # Riboflavin (mg/100g)
  riboflavin: Float

  # Niacin (mg/100g)
  niacin: Float

  # Pantothenic acid (mg/100g)
  pantoAcid: Float

  # Vitamin B6 (mg/100g)
  vitaminB6: Float

  # Folate, total (μg/100g)
  folate: Float

  # Folic acid (μg/100g)
  folicAcid: Float

  # Food folate (μg/100g)
  foodFolate: Float

  # Folate (μg dietary folate equivalents/100g)
  folateDfe: Float

  # Choline, total (mg/100g)
  choline: Float

  # Vitamin B12 (μg/100g)
  vitaminB12: Float

  # Vitamin A (IU/100g)
  vitaminAIu: Float

  # Vitamin A (μg retinol activity equivalents/100g)
  vitaminARae: Float

  # Retinol (μg/100g)
  retinol: Float

  # Alpha-carotene (μg/100g)
  alphaCarot: Float

  # Beta-carotene (μg/100g)
  betaCarot: Float

  # Beta-cryptoxanthin (μg/100g)
  betaCrypt: Float

  # Lycopene (μg/100g)
  lycopene: Float

  # Lutein+zeazanthin (μg/100g)
  lutZea: Float

  # Vitamin E (alpha-tocopherol) (mg/100g)
  vitaminE: Float

  # Vitamin D (μg/100g)
  vitaminDMcg: Float

  # Vitamin D (IU/100g)
  vitaminDIu: Float

  # Vitamin K (phylloquinone) (μg/100g)
  vitaminK: Float

  # Saturated fatty acid (g/100g)
  fatSat: Float

  # Monounsaturated fatty acids (g/100g)
  fatMono: Float

  # Polyunsaturated fatty acids (g/100g)
  fatPoly: Float

  # Cholesterol (mg/100g)
  cholesterol: Float

  # The time this object was created.
  createdAt: Datetime

  # The time this object was last updated.
  updatedAt: Datetime
}

# Contains the nutrient values and information about the values, including expanded statistical information.
type FoodNutrient implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # 5-digit or 8-digit Nutrient Databank number that uniquely identifies a food item.
  foodId: Float!

  # Unique 3-digit identifier code for a nutrient.
  nutrientId: Float!

  # Amount in 100 grams, edible portion.
  nutrientValue: Float!

  # Standard error of the mean. Null if cannot be calculated. The standard error
  # is also not given if the number of data points is less than three.
  standardError: Float

  # Minimum value.
  min: Float

  # Maximum value.
  max: Float

  # Lower 95% error bound.
  lowerErrorBound: Float

  # Upper 95% error bound.
  upperErrorBound: Float
  source: InputSource

  # The unique identifier for the user who created the food nutrient values.
  userId: UUID

  # Reads a single `Food` that is related to this `FoodNutrient`.
  foodByFoodId: Food!

  # Reads a single `Nutrient` that is related to this `FoodNutrient`.
  nutrientByNutrientId: Nutrient!

  # Reads a single `User` that is related to this `FoodNutrient`.
  userByUserId: User
}

# A condition to be used against `FoodNutrient` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input FoodNutrientCondition {
  # Checks for equality with the object’s `foodId` field.
  foodId: Float

  # Checks for equality with the object’s `nutrientId` field.
  nutrientId: Float

  # Checks for equality with the object’s `nutrientValue` field.
  nutrientValue: Float

  # Checks for equality with the object’s `standardError` field.
  standardError: Float

  # Checks for equality with the object’s `min` field.
  min: Float

  # Checks for equality with the object’s `max` field.
  max: Float

  # Checks for equality with the object’s `lowerErrorBound` field.
  lowerErrorBound: Float

  # Checks for equality with the object’s `upperErrorBound` field.
  upperErrorBound: Float

  # Checks for equality with the object’s `source` field.
  source: InputSource

  # Checks for equality with the object’s `userId` field.
  userId: UUID
}

# An input for mutations affecting `FoodNutrient`
input FoodNutrientInput {
  # 5-digit or 8-digit Nutrient Databank number that uniquely identifies a food item.
  foodId: Float!

  # Unique 3-digit identifier code for a nutrient.
  nutrientId: Float!

  # Amount in 100 grams, edible portion.
  nutrientValue: Float!

  # Standard error of the mean. Null if cannot be calculated. The standard error
  # is also not given if the number of data points is less than three.
  standardError: Float

  # Minimum value.
  min: Float

  # Maximum value.
  max: Float

  # Lower 95% error bound.
  lowerErrorBound: Float

  # Upper 95% error bound.
  upperErrorBound: Float
  source: InputSource

  # The unique identifier for the user who created the food nutrient values.
  userId: UUID
}

# Represents an update to a `FoodNutrient`. Fields that are set will be updated.
input FoodNutrientPatch {
  # 5-digit or 8-digit Nutrient Databank number that uniquely identifies a food item.
  foodId: Float

  # Unique 3-digit identifier code for a nutrient.
  nutrientId: Float

  # Amount in 100 grams, edible portion.
  nutrientValue: Float

  # Standard error of the mean. Null if cannot be calculated. The standard error
  # is also not given if the number of data points is less than three.
  standardError: Float

  # Minimum value.
  min: Float

  # Maximum value.
  max: Float

  # Lower 95% error bound.
  lowerErrorBound: Float

  # Upper 95% error bound.
  upperErrorBound: Float
  source: InputSource

  # The unique identifier for the user who created the food nutrient values.
  userId: UUID
}

# A connection to a list of `FoodNutrient` values.
type FoodNutrientsConnection {
  # A list of `FoodNutrient` objects.
  nodes: [FoodNutrient]!

  # A list of edges which contains the `FoodNutrient` and cursor to aid in pagination.
  edges: [FoodNutrientsEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `FoodNutrient` you could get from the connection.
  totalCount: Int
}

# A `FoodNutrient` edge in the connection.
type FoodNutrientsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `FoodNutrient` at the end of the edge.
  node: FoodNutrient!
}

# Methods to use when ordering `FoodNutrient`.
enum FoodNutrientsOrderBy {
  NATURAL
  FOOD_ID_ASC
  FOOD_ID_DESC
  NUTRIENT_ID_ASC
  NUTRIENT_ID_DESC
  NUTRIENT_VALUE_ASC
  NUTRIENT_VALUE_DESC
  STANDARD_ERROR_ASC
  STANDARD_ERROR_DESC
  MIN_ASC
  MIN_DESC
  MAX_ASC
  MAX_DESC
  LOWER_ERROR_BOUND_ASC
  LOWER_ERROR_BOUND_DESC
  UPPER_ERROR_BOUND_ASC
  UPPER_ERROR_BOUND_DESC
  SOURCE_ASC
  SOURCE_DESC
  USER_ID_ASC
  USER_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

# Represents an update to a `Food`. Fields that are set will be updated.
input FoodPatch {
  # 5-digit or 8-digit Nutrient Databank number that uniquely identifies a food item.
  rowId: Float

  # 4-digit code indicating food group to which a food item belongs.
  foodGroupId: Float

  # Indicates the company that manufactured the product, when appropriate.
  brandName: String

  # 200-character description of food item.
  description: String

  # Description of inedible parts of a food item (refuse), such as seeds or bone.
  refuseDescription: String

  # Percentage of refuse.
  refuse: Float

  # Factor for calculating calories from protein.
  proteinFactor: Float

  # Factor for calculating calories from fat.
  fatFactor: Float

  # Factor for calculating calories from carbohydrate.
  carbFactor: Float
  source: InputSource

  # The unique identifier for the user who created the food.
  userId: UUID

  # Water (g/100g)
  water: Float

  # Food energy (kcal/100g)
  calories: Float

  # Protein (g/100g)
  protein: Float

  # Total lipid (fat) (g/100g)
  fat: Float

  # Ash (g/100g)
  ash: Float

  # Carbohydrate, by difference (g/100g)
  carbs: Float

  # Total dietary fiber (g/100g)
  fiber: Float

  # Total sugars (g/100g)
  sugar: Float

  # Calcium (mg/100g)
  calcium: Float

  # Iron (mg/100g)
  iron: Float

  # Magnesium (mg/100g)
  magnesium: Float

  # Phosphorus (mg/100g)
  phosphorus: Float

  # Potassium (mg/100g)
  potassium: Float

  # Sodium (mg/100g)
  sodium: Float

  # Zinc (mg/100g)
  zinc: Float

  # Copper (mg/100g)
  copper: Float

  # Manganese (mg/100g)
  manganese: Float

  # Selenium (μg/100g)
  selenium: Float

  # Vitamin C (mg/100g)
  vitaminC: Float

  # Thiamin (mg/100g)
  thiamin: Float

  # Riboflavin (mg/100g)
  riboflavin: Float

  # Niacin (mg/100g)
  niacin: Float

  # Pantothenic acid (mg/100g)
  pantoAcid: Float

  # Vitamin B6 (mg/100g)
  vitaminB6: Float

  # Folate, total (μg/100g)
  folate: Float

  # Folic acid (μg/100g)
  folicAcid: Float

  # Food folate (μg/100g)
  foodFolate: Float

  # Folate (μg dietary folate equivalents/100g)
  folateDfe: Float

  # Choline, total (mg/100g)
  choline: Float

  # Vitamin B12 (μg/100g)
  vitaminB12: Float

  # Vitamin A (IU/100g)
  vitaminAIu: Float

  # Vitamin A (μg retinol activity equivalents/100g)
  vitaminARae: Float

  # Retinol (μg/100g)
  retinol: Float

  # Alpha-carotene (μg/100g)
  alphaCarot: Float

  # Beta-carotene (μg/100g)
  betaCarot: Float

  # Beta-cryptoxanthin (μg/100g)
  betaCrypt: Float

  # Lycopene (μg/100g)
  lycopene: Float

  # Lutein+zeazanthin (μg/100g)
  lutZea: Float

  # Vitamin E (alpha-tocopherol) (mg/100g)
  vitaminE: Float

  # Vitamin D (μg/100g)
  vitaminDMcg: Float

  # Vitamin D (IU/100g)
  vitaminDIu: Float

  # Vitamin K (phylloquinone) (μg/100g)
  vitaminK: Float

  # Saturated fatty acid (g/100g)
  fatSat: Float

  # Monounsaturated fatty acids (g/100g)
  fatMono: Float

  # Polyunsaturated fatty acids (g/100g)
  fatPoly: Float

  # Cholesterol (mg/100g)
  cholesterol: Float

  # The time this object was created.
  createdAt: Datetime

  # The time this object was last updated.
  updatedAt: Datetime
}

# A connection to a list of `Food` values.
type FoodsConnection {
  # A list of `Food` objects.
  nodes: [Food]!

  # A list of edges which contains the `Food` and cursor to aid in pagination.
  edges: [FoodsEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Food` you could get from the connection.
  totalCount: Int
}

# A `Food` edge in the connection.
type FoodsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Food` at the end of the edge.
  node: Food!
}

# A food item entered into a person’s food journal, like an ingredient or dish.
type FoodSelection implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # The food selection’s unique identifier.
  rowId: UUID!

  # The unique identifier for the person.
  userId: UUID!

  # The unique identifier for the message.
  messageId: UUID

  # The unique identifier for the preset that this selection was copied from.
  inheritsFromId: UUID
  category: FoodSelectionCategory

  # The unique identifier for the food.
  foodId: Float
  foodIdStatus: InvestigationStatus

  # Investigation notes about finding the right food id for the food selection
  foodIdNotes: String

  # The total mass of the food in grams.
  mass: Float
  massStatus: InvestigationStatus

  # Investigation notes about converting the mass of the food selection.
  massNotes: String

  # The description of the food.
  foodDescription: String!

  # The numeric component for describing quantity of food: e.x. 1/4 in 1/4 cup, 200 in 200 grams.
  unitAmount: Float

  # The description of the unit of measure.
  unitDescription: String

  # The unique identifier for the unit of measure, if mentioned.
  unitOfMeasureId: Int

  # The description of a physical modification, e.x. chopped, julienned, melted, etc.
  physicalModDescription: String

  # The description of the brand.
  brandDescription: String

  # The date the food selection occurred, local to the person.
  date: Date!

  # The time the food selection occurred, local to the person.
  time: Time

  # The time this object was created.
  createdAt: Datetime

  # The time this object was last updated.
  updatedAt: Datetime

  # Reads a single `User` that is related to this `FoodSelection`.
  userByUserId: User!

  # Reads a single `Message` that is related to this `FoodSelection`.
  messageByMessageId: Message

  # Reads a single `Preset` that is related to this `FoodSelection`.
  presetByInheritsFromId: Preset

  # Reads a single `Food` that is related to this `FoodSelection`.
  foodByFoodId: Food

  # Reads a single `UnitOfMeasure` that is related to this `FoodSelection`.
  unitOfMeasureByUnitOfMeasureId: UnitOfMeasure

  # Reads and enables pagination through a set of `PresetSelection`.
  presetSelectionsBySelectionId(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `PresetSelection`.
    orderBy: PresetSelectionsOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: PresetSelectionCondition
  ): PresetSelectionsConnection!
}

# The category of a food selection: collection (buying or acquiring), preparation
# (cooking, preserving, or prepping), consumption (eating), observation (general
# fallback for making a note about food).
enum FoodSelectionCategory {
  COLLECTION
  PREPARATION
  CONSUMPTION
  OBSERVATION
}

# A condition to be used against `FoodSelection` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input FoodSelectionCondition {
  # Checks for equality with the object’s `rowId` field.
  rowId: UUID

  # Checks for equality with the object’s `userId` field.
  userId: UUID

  # Checks for equality with the object’s `messageId` field.
  messageId: UUID

  # Checks for equality with the object’s `inheritsFromId` field.
  inheritsFromId: UUID

  # Checks for equality with the object’s `category` field.
  category: FoodSelectionCategory

  # Checks for equality with the object’s `foodId` field.
  foodId: Float

  # Checks for equality with the object’s `foodIdStatus` field.
  foodIdStatus: InvestigationStatus

  # Checks for equality with the object’s `foodIdNotes` field.
  foodIdNotes: String

  # Checks for equality with the object’s `mass` field.
  mass: Float

  # Checks for equality with the object’s `massStatus` field.
  massStatus: InvestigationStatus

  # Checks for equality with the object’s `massNotes` field.
  massNotes: String

  # Checks for equality with the object’s `foodDescription` field.
  foodDescription: String

  # Checks for equality with the object’s `unitAmount` field.
  unitAmount: Float

  # Checks for equality with the object’s `unitDescription` field.
  unitDescription: String

  # Checks for equality with the object’s `unitOfMeasureId` field.
  unitOfMeasureId: Int

  # Checks for equality with the object’s `physicalModDescription` field.
  physicalModDescription: String

  # Checks for equality with the object’s `brandDescription` field.
  brandDescription: String

  # Checks for equality with the object’s `date` field.
  date: Date

  # Checks for equality with the object’s `time` field.
  time: Time

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# An input for mutations affecting `FoodSelection`
input FoodSelectionInput {
  # The food selection’s unique identifier.
  rowId: UUID

  # The unique identifier for the person.
  userId: UUID!

  # The unique identifier for the message.
  messageId: UUID

  # The unique identifier for the preset that this selection was copied from.
  inheritsFromId: UUID
  category: FoodSelectionCategory

  # The unique identifier for the food.
  foodId: Float
  foodIdStatus: InvestigationStatus

  # Investigation notes about finding the right food id for the food selection
  foodIdNotes: String

  # The total mass of the food in grams.
  mass: Float
  massStatus: InvestigationStatus

  # Investigation notes about converting the mass of the food selection.
  massNotes: String

  # The description of the food.
  foodDescription: String!

  # The numeric component for describing quantity of food: e.x. 1/4 in 1/4 cup, 200 in 200 grams.
  unitAmount: Float

  # The description of the unit of measure.
  unitDescription: String

  # The unique identifier for the unit of measure, if mentioned.
  unitOfMeasureId: Int

  # The description of a physical modification, e.x. chopped, julienned, melted, etc.
  physicalModDescription: String

  # The description of the brand.
  brandDescription: String

  # The date the food selection occurred, local to the person.
  date: Date

  # The time the food selection occurred, local to the person.
  time: Time

  # The time this object was created.
  createdAt: Datetime

  # The time this object was last updated.
  updatedAt: Datetime
}

# Represents an update to a `FoodSelection`. Fields that are set will be updated.
input FoodSelectionPatch {
  # The food selection’s unique identifier.
  rowId: UUID

  # The unique identifier for the person.
  userId: UUID

  # The unique identifier for the message.
  messageId: UUID

  # The unique identifier for the preset that this selection was copied from.
  inheritsFromId: UUID
  category: FoodSelectionCategory

  # The unique identifier for the food.
  foodId: Float
  foodIdStatus: InvestigationStatus

  # Investigation notes about finding the right food id for the food selection
  foodIdNotes: String

  # The total mass of the food in grams.
  mass: Float
  massStatus: InvestigationStatus

  # Investigation notes about converting the mass of the food selection.
  massNotes: String

  # The description of the food.
  foodDescription: String

  # The numeric component for describing quantity of food: e.x. 1/4 in 1/4 cup, 200 in 200 grams.
  unitAmount: Float

  # The description of the unit of measure.
  unitDescription: String

  # The unique identifier for the unit of measure, if mentioned.
  unitOfMeasureId: Int

  # The description of a physical modification, e.x. chopped, julienned, melted, etc.
  physicalModDescription: String

  # The description of the brand.
  brandDescription: String

  # The date the food selection occurred, local to the person.
  date: Date

  # The time the food selection occurred, local to the person.
  time: Time

  # The time this object was created.
  createdAt: Datetime

  # The time this object was last updated.
  updatedAt: Datetime
}

# A connection to a list of `FoodSelection` values.
type FoodSelectionsConnection {
  # A list of `FoodSelection` objects.
  nodes: [FoodSelection]!

  # A list of edges which contains the `FoodSelection` and cursor to aid in pagination.
  edges: [FoodSelectionsEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `FoodSelection` you could get from the connection.
  totalCount: Int
}

# A `FoodSelection` edge in the connection.
type FoodSelectionsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `FoodSelection` at the end of the edge.
  node: FoodSelection!
}

# Methods to use when ordering `FoodSelection`.
enum FoodSelectionsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  MESSAGE_ID_ASC
  MESSAGE_ID_DESC
  INHERITS_FROM_ID_ASC
  INHERITS_FROM_ID_DESC
  CATEGORY_ASC
  CATEGORY_DESC
  FOOD_ID_ASC
  FOOD_ID_DESC
  FOOD_ID_STATUS_ASC
  FOOD_ID_STATUS_DESC
  FOOD_ID_NOTES_ASC
  FOOD_ID_NOTES_DESC
  MASS_ASC
  MASS_DESC
  MASS_STATUS_ASC
  MASS_STATUS_DESC
  MASS_NOTES_ASC
  MASS_NOTES_DESC
  FOOD_DESCRIPTION_ASC
  FOOD_DESCRIPTION_DESC
  UNIT_AMOUNT_ASC
  UNIT_AMOUNT_DESC
  UNIT_DESCRIPTION_ASC
  UNIT_DESCRIPTION_DESC
  UNIT_OF_MEASURE_ID_ASC
  UNIT_OF_MEASURE_ID_DESC
  PHYSICAL_MOD_DESCRIPTION_ASC
  PHYSICAL_MOD_DESCRIPTION_DESC
  BRAND_DESCRIPTION_ASC
  BRAND_DESCRIPTION_DESC
  DATE_ASC
  DATE_DESC
  TIME_ASC
  TIME_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

# Methods to use when ordering `Food`.
enum FoodsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  FOOD_GROUP_ID_ASC
  FOOD_GROUP_ID_DESC
  BRAND_NAME_ASC
  BRAND_NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  REFUSE_DESCRIPTION_ASC
  REFUSE_DESCRIPTION_DESC
  REFUSE_ASC
  REFUSE_DESC
  PROTEIN_FACTOR_ASC
  PROTEIN_FACTOR_DESC
  FAT_FACTOR_ASC
  FAT_FACTOR_DESC
  CARB_FACTOR_ASC
  CARB_FACTOR_DESC
  SOURCE_ASC
  SOURCE_DESC
  USER_ID_ASC
  USER_ID_DESC
  WATER_ASC
  WATER_DESC
  CALORIES_ASC
  CALORIES_DESC
  PROTEIN_ASC
  PROTEIN_DESC
  FAT_ASC
  FAT_DESC
  ASH_ASC
  ASH_DESC
  CARBS_ASC
  CARBS_DESC
  FIBER_ASC
  FIBER_DESC
  SUGAR_ASC
  SUGAR_DESC
  CALCIUM_ASC
  CALCIUM_DESC
  IRON_ASC
  IRON_DESC
  MAGNESIUM_ASC
  MAGNESIUM_DESC
  PHOSPHORUS_ASC
  PHOSPHORUS_DESC
  POTASSIUM_ASC
  POTASSIUM_DESC
  SODIUM_ASC
  SODIUM_DESC
  ZINC_ASC
  ZINC_DESC
  COPPER_ASC
  COPPER_DESC
  MANGANESE_ASC
  MANGANESE_DESC
  SELENIUM_ASC
  SELENIUM_DESC
  VITAMIN_C_ASC
  VITAMIN_C_DESC
  THIAMIN_ASC
  THIAMIN_DESC
  RIBOFLAVIN_ASC
  RIBOFLAVIN_DESC
  NIACIN_ASC
  NIACIN_DESC
  PANTO_ACID_ASC
  PANTO_ACID_DESC
  VITAMIN_B6_ASC
  VITAMIN_B6_DESC
  FOLATE_ASC
  FOLATE_DESC
  FOLIC_ACID_ASC
  FOLIC_ACID_DESC
  FOOD_FOLATE_ASC
  FOOD_FOLATE_DESC
  FOLATE_DFE_ASC
  FOLATE_DFE_DESC
  CHOLINE_ASC
  CHOLINE_DESC
  VITAMIN_B12_ASC
  VITAMIN_B12_DESC
  VITAMIN_A_IU_ASC
  VITAMIN_A_IU_DESC
  VITAMIN_A_RAE_ASC
  VITAMIN_A_RAE_DESC
  RETINOL_ASC
  RETINOL_DESC
  ALPHA_CAROT_ASC
  ALPHA_CAROT_DESC
  BETA_CAROT_ASC
  BETA_CAROT_DESC
  BETA_CRYPT_ASC
  BETA_CRYPT_DESC
  LYCOPENE_ASC
  LYCOPENE_DESC
  LUT_ZEA_ASC
  LUT_ZEA_DESC
  VITAMIN_E_ASC
  VITAMIN_E_DESC
  VITAMIN_D_MCG_ASC
  VITAMIN_D_MCG_DESC
  VITAMIN_D_IU_ASC
  VITAMIN_D_IU_DESC
  VITAMIN_K_ASC
  VITAMIN_K_DESC
  FAT_SAT_ASC
  FAT_SAT_DESC
  FAT_MONO_ASC
  FAT_MONO_DESC
  FAT_POLY_ASC
  FAT_POLY_DESC
  CHOLESTEROL_ASC
  CHOLESTEROL_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type GeocodeResult {
  geoRating: Int
  lon: Float
  lat: Float
  streetNumber: Int
  streetName: String
  streetType: String
  city: String
  state: String
  zip: String
}

# Describes the source of data for a table row: developer is someone who
# administers the database, agent is a machine learning algorithm, user is a
# person who manually input the data through the app.
enum InputSource {
  DEVELOPER
  AGENT
  USER
  USDA_SR28
}

# The lifecycle for investigating a food id or mass for a food selection.
enum InvestigationStatus {
  REQUESTED
  ANSWERED
  REJECTED
  REANSWERED
  ACCEPTED
  SUPERSEDED
}

# A JSON Web Token defined by [RFC 7519](https://tools.ietf.org/html/rfc7519)
# which securely represents claims between two parties.
scalar JwtToken

# Contains a factor for converting a volume or count unit into grams for a given food item and physical form.
type MassConversion implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!
  rowId: Int!

  # The unique identifier for the food item.
  foodId: Float!

  # The unique identifier for the initial unit of measure which is a volume or count unit, e.x. liter, drumstick, piece, box.
  unitOfMeasureId: Int!

  # The description of a physical modification, e.x. chopped, julienned, melted,
  # etc., which affects density but not nutrition per mass.
  physicalModDescription: String

  # The mass equivalent in grams.
  mass: Float
  source: InputSource

  # The unique identifier for the user who created the mass conversion record.
  userId: UUID

  # Reads a single `Food` that is related to this `MassConversion`.
  foodByFoodId: Food!

  # Reads a single `UnitOfMeasure` that is related to this `MassConversion`.
  unitOfMeasureByUnitOfMeasureId: UnitOfMeasure!

  # Reads a single `User` that is related to this `MassConversion`.
  userByUserId: User
}

# A condition to be used against `MassConversion` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input MassConversionCondition {
  # Checks for equality with the object’s `rowId` field.
  rowId: Int

  # Checks for equality with the object’s `foodId` field.
  foodId: Float

  # Checks for equality with the object’s `unitOfMeasureId` field.
  unitOfMeasureId: Int

  # Checks for equality with the object’s `physicalModDescription` field.
  physicalModDescription: String

  # Checks for equality with the object’s `mass` field.
  mass: Float

  # Checks for equality with the object’s `source` field.
  source: InputSource

  # Checks for equality with the object’s `userId` field.
  userId: UUID
}

# An input for mutations affecting `MassConversion`
input MassConversionInput {
  rowId: Int

  # The unique identifier for the food item.
  foodId: Float!

  # The unique identifier for the initial unit of measure which is a volume or count unit, e.x. liter, drumstick, piece, box.
  unitOfMeasureId: Int!

  # The description of a physical modification, e.x. chopped, julienned, melted,
  # etc., which affects density but not nutrition per mass.
  physicalModDescription: String

  # The mass equivalent in grams.
  mass: Float
  source: InputSource

  # The unique identifier for the user who created the mass conversion record.
  userId: UUID
}

# Represents an update to a `MassConversion`. Fields that are set will be updated.
input MassConversionPatch {
  rowId: Int

  # The unique identifier for the food item.
  foodId: Float

  # The unique identifier for the initial unit of measure which is a volume or count unit, e.x. liter, drumstick, piece, box.
  unitOfMeasureId: Int

  # The description of a physical modification, e.x. chopped, julienned, melted,
  # etc., which affects density but not nutrition per mass.
  physicalModDescription: String

  # The mass equivalent in grams.
  mass: Float
  source: InputSource

  # The unique identifier for the user who created the mass conversion record.
  userId: UUID
}

# A connection to a list of `MassConversion` values.
type MassConversionsConnection {
  # A list of `MassConversion` objects.
  nodes: [MassConversion]!

  # A list of edges which contains the `MassConversion` and cursor to aid in pagination.
  edges: [MassConversionsEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `MassConversion` you could get from the connection.
  totalCount: Int
}

# A `MassConversion` edge in the connection.
type MassConversionsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `MassConversion` at the end of the edge.
  node: MassConversion!
}

# Methods to use when ordering `MassConversion`.
enum MassConversionsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  FOOD_ID_ASC
  FOOD_ID_DESC
  UNIT_OF_MEASURE_ID_ASC
  UNIT_OF_MEASURE_ID_DESC
  PHYSICAL_MOD_DESCRIPTION_ASC
  PHYSICAL_MOD_DESCRIPTION_DESC
  MASS_ASC
  MASS_DESC
  SOURCE_ASC
  SOURCE_DESC
  USER_ID_ASC
  USER_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

# A message sent by a person to the agent.
type Message implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # The unique identifier for the message which is provided by the agent.
  rowId: UUID!

  # The unique identifier for the conversation session.
  conversationId: UUID!

  # The agent’s language.
  lang: String

  # HTTP status code of the agent request.
  statusCode: Float
  originalText: String

  # Matching score for the intent.
  score: Float

  # Name of the webhook action determined by the agent.
  action: String
  source: InputSource

  # The UTC timestamp that the agent included in the original message.
  sentAt: Datetime

  # The time this object was created.
  createdAt: Datetime

  # Reads a single `Conversation` that is related to this `Message`.
  conversationByConversationId: Conversation!

  # Reads and enables pagination through a set of `Preset`.
  presetsByMessageId(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `Preset`.
    orderBy: PresetsOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: PresetCondition
  ): PresetsConnection!

  # Reads and enables pagination through a set of `FoodSelection`.
  foodSelectionsByMessageId(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `FoodSelection`.
    orderBy: FoodSelectionsOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: FoodSelectionCondition
  ): FoodSelectionsConnection!
}

# A condition to be used against `Message` object types. All fields are tested for equality and combined with a logical ‘and.’
input MessageCondition {
  # Checks for equality with the object’s `rowId` field.
  rowId: UUID

  # Checks for equality with the object’s `conversationId` field.
  conversationId: UUID

  # Checks for equality with the object’s `lang` field.
  lang: String

  # Checks for equality with the object’s `statusCode` field.
  statusCode: Float

  # Checks for equality with the object’s `originalText` field.
  originalText: String

  # Checks for equality with the object’s `score` field.
  score: Float

  # Checks for equality with the object’s `action` field.
  action: String

  # Checks for equality with the object’s `source` field.
  source: InputSource

  # Checks for equality with the object’s `sentAt` field.
  sentAt: Datetime

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime
}

# An input for mutations affecting `Message`
input MessageInput {
  # The unique identifier for the message which is provided by the agent.
  rowId: UUID

  # The unique identifier for the conversation session.
  conversationId: UUID!

  # The agent’s language.
  lang: String

  # HTTP status code of the agent request.
  statusCode: Float
  originalText: String

  # Matching score for the intent.
  score: Float

  # Name of the webhook action determined by the agent.
  action: String
  source: InputSource

  # The UTC timestamp that the agent included in the original message.
  sentAt: Datetime

  # The time this object was created.
  createdAt: Datetime
}

# Represents an update to a `Message`. Fields that are set will be updated.
input MessagePatch {
  # The unique identifier for the message which is provided by the agent.
  rowId: UUID

  # The unique identifier for the conversation session.
  conversationId: UUID

  # The agent’s language.
  lang: String

  # HTTP status code of the agent request.
  statusCode: Float
  originalText: String

  # Matching score for the intent.
  score: Float

  # Name of the webhook action determined by the agent.
  action: String
  source: InputSource

  # The UTC timestamp that the agent included in the original message.
  sentAt: Datetime

  # The time this object was created.
  createdAt: Datetime
}

# A connection to a list of `Message` values.
type MessagesConnection {
  # A list of `Message` objects.
  nodes: [Message]!

  # A list of edges which contains the `Message` and cursor to aid in pagination.
  edges: [MessagesEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Message` you could get from the connection.
  totalCount: Int
}

# A `Message` edge in the connection.
type MessagesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Message` at the end of the edge.
  node: Message!
}

# Methods to use when ordering `Message`.
enum MessagesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CONVERSATION_ID_ASC
  CONVERSATION_ID_DESC
  LANG_ASC
  LANG_DESC
  STATUS_CODE_ASC
  STATUS_CODE_DESC
  ORIGINAL_TEXT_ASC
  ORIGINAL_TEXT_DESC
  SCORE_ASC
  SCORE_DESC
  ACTION_ASC
  ACTION_DESC
  SOURCE_ASC
  SOURCE_DESC
  SENT_AT_ASC
  SENT_AT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

# The root mutation type which contains root level fields which mutate data.
type Mutation {
  # Creates a single `Brand`.
  createBrand(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateBrandInput!
  ): CreateBrandPayload

  # Creates a single `Conversation`.
  createConversation(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateConversationInput!
  ): CreateConversationPayload

  # Creates a single `Food`.
  createFood(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateFoodInput!
  ): CreateFoodPayload

  # Creates a single `FoodGroup`.
  createFoodGroup(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateFoodGroupInput!
  ): CreateFoodGroupPayload

  # Creates a single `FoodNutrient`.
  createFoodNutrient(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateFoodNutrientInput!
  ): CreateFoodNutrientPayload

  # Creates a single `FoodSelection`.
  createFoodSelection(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateFoodSelectionInput!
  ): CreateFoodSelectionPayload

  # Creates a single `MassConversion`.
  createMassConversion(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateMassConversionInput!
  ): CreateMassConversionPayload

  # Creates a single `Message`.
  createMessage(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateMessageInput!
  ): CreateMessagePayload

  # Creates a single `Nutrient`.
  createNutrient(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateNutrientInput!
  ): CreateNutrientPayload

  # Creates a single `Place`.
  createPlace(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreatePlaceInput!
  ): CreatePlacePayload

  # Creates a single `Preset`.
  createPreset(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreatePresetInput!
  ): CreatePresetPayload

  # Creates a single `PresetSelection`.
  createPresetSelection(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreatePresetSelectionInput!
  ): CreatePresetSelectionPayload

  # Creates a single `UnitOfMeasure`.
  createUnitOfMeasure(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateUnitOfMeasureInput!
  ): CreateUnitOfMeasurePayload

  # Creates a single `User`.
  createUser(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateUserInput!
  ): CreateUserPayload

  # Updates a single `Brand` using its globally unique id and a patch.
  updateBrand(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateBrandInput!
  ): UpdateBrandPayload

  # Updates a single `Brand` using a unique key and a patch.
  updateBrandByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateBrandByRowIdInput!
  ): UpdateBrandPayload

  # Updates a single `Brand` using a unique key and a patch.
  updateBrandByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateBrandByNameInput!
  ): UpdateBrandPayload

  # Updates a single `Brand` using a unique key and a patch.
  updateBrandByEmail(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateBrandByEmailInput!
  ): UpdateBrandPayload

  # Updates a single `Brand` using a unique key and a patch.
  updateBrandByPhone(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateBrandByPhoneInput!
  ): UpdateBrandPayload

  # Updates a single `Conversation` using its globally unique id and a patch.
  updateConversation(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateConversationInput!
  ): UpdateConversationPayload

  # Updates a single `Conversation` using a unique key and a patch.
  updateConversationByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateConversationByRowIdInput!
  ): UpdateConversationPayload

  # Updates a single `Food` using its globally unique id and a patch.
  updateFood(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateFoodInput!
  ): UpdateFoodPayload

  # Updates a single `Food` using a unique key and a patch.
  updateFoodByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateFoodByRowIdInput!
  ): UpdateFoodPayload

  # Updates a single `FoodGroup` using its globally unique id and a patch.
  updateFoodGroup(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateFoodGroupInput!
  ): UpdateFoodGroupPayload

  # Updates a single `FoodGroup` using a unique key and a patch.
  updateFoodGroupByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateFoodGroupByRowIdInput!
  ): UpdateFoodGroupPayload

  # Updates a single `FoodNutrient` using its globally unique id and a patch.
  updateFoodNutrient(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateFoodNutrientInput!
  ): UpdateFoodNutrientPayload

  # Updates a single `FoodNutrient` using a unique key and a patch.
  updateFoodNutrientByFoodIdAndNutrientId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateFoodNutrientByFoodIdAndNutrientIdInput!
  ): UpdateFoodNutrientPayload

  # Updates a single `FoodSelection` using its globally unique id and a patch.
  updateFoodSelection(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateFoodSelectionInput!
  ): UpdateFoodSelectionPayload

  # Updates a single `FoodSelection` using a unique key and a patch.
  updateFoodSelectionByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateFoodSelectionByRowIdInput!
  ): UpdateFoodSelectionPayload

  # Updates a single `MassConversion` using its globally unique id and a patch.
  updateMassConversion(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateMassConversionInput!
  ): UpdateMassConversionPayload

  # Updates a single `MassConversion` using a unique key and a patch.
  updateMassConversionByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateMassConversionByRowIdInput!
  ): UpdateMassConversionPayload

  # Updates a single `MassConversion` using a unique key and a patch.
  updateMassConversionByFoodIdAndUnitOfMeasureIdAndPhysicalModDescription(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateMassConversionByFoodIdAndUnitOfMeasureIdAndPhysicalModDescriptionInput!
  ): UpdateMassConversionPayload

  # Updates a single `Message` using its globally unique id and a patch.
  updateMessage(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateMessageInput!
  ): UpdateMessagePayload

  # Updates a single `Message` using a unique key and a patch.
  updateMessageByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateMessageByRowIdInput!
  ): UpdateMessagePayload

  # Updates a single `Nutrient` using its globally unique id and a patch.
  updateNutrient(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateNutrientInput!
  ): UpdateNutrientPayload

  # Updates a single `Nutrient` using a unique key and a patch.
  updateNutrientByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateNutrientByRowIdInput!
  ): UpdateNutrientPayload

  # Updates a single `Place` using its globally unique id and a patch.
  updatePlace(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePlaceInput!
  ): UpdatePlacePayload

  # Updates a single `Place` using a unique key and a patch.
  updatePlaceByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePlaceByRowIdInput!
  ): UpdatePlacePayload

  # Updates a single `Place` using a unique key and a patch.
  updatePlaceByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePlaceByNameInput!
  ): UpdatePlacePayload

  # Updates a single `Preset` using its globally unique id and a patch.
  updatePreset(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePresetInput!
  ): UpdatePresetPayload

  # Updates a single `Preset` using a unique key and a patch.
  updatePresetByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePresetByRowIdInput!
  ): UpdatePresetPayload

  # Updates a single `Preset` using a unique key and a patch.
  updatePresetByUserIdAndName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePresetByUserIdAndNameInput!
  ): UpdatePresetPayload

  # Updates a single `PresetSelection` using its globally unique id and a patch.
  updatePresetSelection(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePresetSelectionInput!
  ): UpdatePresetSelectionPayload

  # Updates a single `PresetSelection` using a unique key and a patch.
  updatePresetSelectionByPresetIdAndSelectionId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePresetSelectionByPresetIdAndSelectionIdInput!
  ): UpdatePresetSelectionPayload

  # Updates a single `UnitOfMeasure` using its globally unique id and a patch.
  updateUnitOfMeasure(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateUnitOfMeasureInput!
  ): UpdateUnitOfMeasurePayload

  # Updates a single `UnitOfMeasure` using a unique key and a patch.
  updateUnitOfMeasureByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateUnitOfMeasureByRowIdInput!
  ): UpdateUnitOfMeasurePayload

  # Updates a single `UnitOfMeasure` using a unique key and a patch.
  updateUnitOfMeasureByFullName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateUnitOfMeasureByFullNameInput!
  ): UpdateUnitOfMeasurePayload

  # Updates a single `UnitOfMeasure` using a unique key and a patch.
  updateUnitOfMeasureByShortName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateUnitOfMeasureByShortNameInput!
  ): UpdateUnitOfMeasurePayload

  # Updates a single `UnitOfMeasure` using a unique key and a patch.
  updateUnitOfMeasureByUsdaKey(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateUnitOfMeasureByUsdaKeyInput!
  ): UpdateUnitOfMeasurePayload

  # Updates a single `User` using its globally unique id and a patch.
  updateUser(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateUserInput!
  ): UpdateUserPayload

  # Updates a single `User` using a unique key and a patch.
  updateUserByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateUserByRowIdInput!
  ): UpdateUserPayload

  # Updates a single `User` using a unique key and a patch.
  updateUserByPhone(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateUserByPhoneInput!
  ): UpdateUserPayload

  # Deletes a single `Brand` using its globally unique id.
  deleteBrand(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteBrandInput!
  ): DeleteBrandPayload

  # Deletes a single `Brand` using a unique key.
  deleteBrandByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteBrandByRowIdInput!
  ): DeleteBrandPayload

  # Deletes a single `Brand` using a unique key.
  deleteBrandByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteBrandByNameInput!
  ): DeleteBrandPayload

  # Deletes a single `Brand` using a unique key.
  deleteBrandByEmail(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteBrandByEmailInput!
  ): DeleteBrandPayload

  # Deletes a single `Brand` using a unique key.
  deleteBrandByPhone(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteBrandByPhoneInput!
  ): DeleteBrandPayload

  # Deletes a single `Conversation` using its globally unique id.
  deleteConversation(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteConversationInput!
  ): DeleteConversationPayload

  # Deletes a single `Conversation` using a unique key.
  deleteConversationByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteConversationByRowIdInput!
  ): DeleteConversationPayload

  # Deletes a single `Food` using its globally unique id.
  deleteFood(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteFoodInput!
  ): DeleteFoodPayload

  # Deletes a single `Food` using a unique key.
  deleteFoodByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteFoodByRowIdInput!
  ): DeleteFoodPayload

  # Deletes a single `FoodGroup` using its globally unique id.
  deleteFoodGroup(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteFoodGroupInput!
  ): DeleteFoodGroupPayload

  # Deletes a single `FoodGroup` using a unique key.
  deleteFoodGroupByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteFoodGroupByRowIdInput!
  ): DeleteFoodGroupPayload

  # Deletes a single `FoodNutrient` using its globally unique id.
  deleteFoodNutrient(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteFoodNutrientInput!
  ): DeleteFoodNutrientPayload

  # Deletes a single `FoodNutrient` using a unique key.
  deleteFoodNutrientByFoodIdAndNutrientId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteFoodNutrientByFoodIdAndNutrientIdInput!
  ): DeleteFoodNutrientPayload

  # Deletes a single `FoodSelection` using its globally unique id.
  deleteFoodSelection(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteFoodSelectionInput!
  ): DeleteFoodSelectionPayload

  # Deletes a single `FoodSelection` using a unique key.
  deleteFoodSelectionByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteFoodSelectionByRowIdInput!
  ): DeleteFoodSelectionPayload

  # Deletes a single `MassConversion` using its globally unique id.
  deleteMassConversion(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteMassConversionInput!
  ): DeleteMassConversionPayload

  # Deletes a single `MassConversion` using a unique key.
  deleteMassConversionByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteMassConversionByRowIdInput!
  ): DeleteMassConversionPayload

  # Deletes a single `MassConversion` using a unique key.
  deleteMassConversionByFoodIdAndUnitOfMeasureIdAndPhysicalModDescription(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteMassConversionByFoodIdAndUnitOfMeasureIdAndPhysicalModDescriptionInput!
  ): DeleteMassConversionPayload

  # Deletes a single `Message` using its globally unique id.
  deleteMessage(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteMessageInput!
  ): DeleteMessagePayload

  # Deletes a single `Message` using a unique key.
  deleteMessageByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteMessageByRowIdInput!
  ): DeleteMessagePayload

  # Deletes a single `Nutrient` using its globally unique id.
  deleteNutrient(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteNutrientInput!
  ): DeleteNutrientPayload

  # Deletes a single `Nutrient` using a unique key.
  deleteNutrientByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteNutrientByRowIdInput!
  ): DeleteNutrientPayload

  # Deletes a single `Place` using its globally unique id.
  deletePlace(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePlaceInput!
  ): DeletePlacePayload

  # Deletes a single `Place` using a unique key.
  deletePlaceByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePlaceByRowIdInput!
  ): DeletePlacePayload

  # Deletes a single `Place` using a unique key.
  deletePlaceByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePlaceByNameInput!
  ): DeletePlacePayload

  # Deletes a single `Preset` using its globally unique id.
  deletePreset(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePresetInput!
  ): DeletePresetPayload

  # Deletes a single `Preset` using a unique key.
  deletePresetByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePresetByRowIdInput!
  ): DeletePresetPayload

  # Deletes a single `Preset` using a unique key.
  deletePresetByUserIdAndName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePresetByUserIdAndNameInput!
  ): DeletePresetPayload

  # Deletes a single `PresetSelection` using its globally unique id.
  deletePresetSelection(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePresetSelectionInput!
  ): DeletePresetSelectionPayload

  # Deletes a single `PresetSelection` using a unique key.
  deletePresetSelectionByPresetIdAndSelectionId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePresetSelectionByPresetIdAndSelectionIdInput!
  ): DeletePresetSelectionPayload

  # Deletes a single `UnitOfMeasure` using its globally unique id.
  deleteUnitOfMeasure(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteUnitOfMeasureInput!
  ): DeleteUnitOfMeasurePayload

  # Deletes a single `UnitOfMeasure` using a unique key.
  deleteUnitOfMeasureByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteUnitOfMeasureByRowIdInput!
  ): DeleteUnitOfMeasurePayload

  # Deletes a single `UnitOfMeasure` using a unique key.
  deleteUnitOfMeasureByFullName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteUnitOfMeasureByFullNameInput!
  ): DeleteUnitOfMeasurePayload

  # Deletes a single `UnitOfMeasure` using a unique key.
  deleteUnitOfMeasureByShortName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteUnitOfMeasureByShortNameInput!
  ): DeleteUnitOfMeasurePayload

  # Deletes a single `UnitOfMeasure` using a unique key.
  deleteUnitOfMeasureByUsdaKey(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteUnitOfMeasureByUsdaKeyInput!
  ): DeleteUnitOfMeasurePayload

  # Deletes a single `User` using its globally unique id.
  deleteUser(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteUserInput!
  ): DeleteUserPayload

  # Deletes a single `User` using a unique key.
  deleteUserByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteUserByRowIdInput!
  ): DeleteUserPayload

  # Deletes a single `User` using a unique key.
  deleteUserByPhone(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteUserByPhoneInput!
  ): DeleteUserPayload

  # Creates a JWT token that will securely identify a person and give them certain permissions.
  authenticateUser(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: AuthenticateUserInput!
  ): AuthenticateUserPayload!

  # Registers a single user and creates an account.
  registerUser(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: RegisterUserInput!
  ): RegisterUserPayload!
}

# An object with a globally unique `ID`.
interface Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!
}

# A support table to the food_nutrient table. It provides the 3-digit nutrient
# code, unit of measure, INFOODS tagname, and description.
type Nutrient implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # Unique 3-digit identifier code for a nutrient.
  rowId: Float!

  # The USDA key for the unit of measure.
  unitOfMeasureUsdaKey: String!

  # International Network of Food Data Systems (INFOODS) Tagnames. A unique
  # abbreviation for a nutrient/food component developed by INFOODS to aid in the
  # interchange of data.
  shortName: String

  # Name of nutrient/food component.
  fullName: String!

  # Reads a single `UnitOfMeasure` that is related to this `Nutrient`.
  unitOfMeasureByUnitOfMeasureUsdaKey: UnitOfMeasure!

  # Reads and enables pagination through a set of `FoodNutrient`.
  foodNutrientsByNutrientId(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `FoodNutrient`.
    orderBy: FoodNutrientsOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: FoodNutrientCondition
  ): FoodNutrientsConnection!
}

# A condition to be used against `Nutrient` object types. All fields are tested
# for equality and combined with a logical ‘and.’
input NutrientCondition {
  # Checks for equality with the object’s `rowId` field.
  rowId: Float

  # Checks for equality with the object’s `unitOfMeasureUsdaKey` field.
  unitOfMeasureUsdaKey: String

  # Checks for equality with the object’s `shortName` field.
  shortName: String

  # Checks for equality with the object’s `fullName` field.
  fullName: String
}

# An input for mutations affecting `Nutrient`
input NutrientInput {
  # Unique 3-digit identifier code for a nutrient.
  rowId: Float!

  # The USDA key for the unit of measure.
  unitOfMeasureUsdaKey: String!

  # International Network of Food Data Systems (INFOODS) Tagnames. A unique
  # abbreviation for a nutrient/food component developed by INFOODS to aid in the
  # interchange of data.
  shortName: String

  # Name of nutrient/food component.
  fullName: String!
}

# Represents an update to a `Nutrient`. Fields that are set will be updated.
input NutrientPatch {
  # Unique 3-digit identifier code for a nutrient.
  rowId: Float

  # The USDA key for the unit of measure.
  unitOfMeasureUsdaKey: String

  # International Network of Food Data Systems (INFOODS) Tagnames. A unique
  # abbreviation for a nutrient/food component developed by INFOODS to aid in the
  # interchange of data.
  shortName: String

  # Name of nutrient/food component.
  fullName: String
}

# A connection to a list of `Nutrient` values.
type NutrientsConnection {
  # A list of `Nutrient` objects.
  nodes: [Nutrient]!

  # A list of edges which contains the `Nutrient` and cursor to aid in pagination.
  edges: [NutrientsEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Nutrient` you could get from the connection.
  totalCount: Int
}

# A `Nutrient` edge in the connection.
type NutrientsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Nutrient` at the end of the edge.
  node: Nutrient!
}

# Methods to use when ordering `Nutrient`.
enum NutrientsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  UNIT_OF_MEASURE_USDA_KEY_ASC
  UNIT_OF_MEASURE_USDA_KEY_DESC
  SHORT_NAME_ASC
  SHORT_NAME_DESC
  FULL_NAME_ASC
  FULL_NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: Cursor

  # When paginating forwards, the cursor to continue.
  endCursor: Cursor
}

# A place that has or sells food.
type Place implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # The unique identifier for the place.
  rowId: UUID!

  # The unique identifier for the user who owns the place.
  ownerId: UUID

  # The name of the person responsible for the place listing. This is a fallback for not having a registered user as owner id.
  ownerName: String

  # The place’s human-readable name.
  name: String!

  # The place’s primary email address.
  email: String

  # The place’s phone number.
  phone: String

  # The place’s external website url.
  url: String

  # A confidence rating from the geocoder.
  geoRating: Int

  # The geographical longitude of the place.
  lon: Float

  # The geographical latitude of the place.
  lat: Float

  # The geographical street number of the place.
  streetNumber: Int

  # The geographical street name of the place.
  streetName: String

  # The geographical street type of the place.
  streetType: String

  # The city of the place.
  city: String

  # The geographical state of the place.
  state: String

  # The zip code of the place.
  zip: String

  # The time this object was created.
  createdAt: Datetime

  # The time this object was last updated.
  updatedAt: Datetime

  # Reads a single `User` that is related to this `Place`.
  userByOwnerId: User
}

# A condition to be used against `Place` object types. All fields are tested for equality and combined with a logical ‘and.’
input PlaceCondition {
  # Checks for equality with the object’s `rowId` field.
  rowId: UUID

  # Checks for equality with the object’s `ownerId` field.
  ownerId: UUID

  # Checks for equality with the object’s `ownerName` field.
  ownerName: String

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `email` field.
  email: String

  # Checks for equality with the object’s `phone` field.
  phone: String

  # Checks for equality with the object’s `url` field.
  url: String

  # Checks for equality with the object’s `geoRating` field.
  geoRating: Int

  # Checks for equality with the object’s `lon` field.
  lon: Float

  # Checks for equality with the object’s `lat` field.
  lat: Float

  # Checks for equality with the object’s `streetNumber` field.
  streetNumber: Int

  # Checks for equality with the object’s `streetName` field.
  streetName: String

  # Checks for equality with the object’s `streetType` field.
  streetType: String

  # Checks for equality with the object’s `city` field.
  city: String

  # Checks for equality with the object’s `state` field.
  state: String

  # Checks for equality with the object’s `zip` field.
  zip: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# An input for mutations affecting `Place`
input PlaceInput {
  # The unique identifier for the place.
  rowId: UUID

  # The unique identifier for the user who owns the place.
  ownerId: UUID

  # The name of the person responsible for the place listing. This is a fallback for not having a registered user as owner id.
  ownerName: String

  # The place’s human-readable name.
  name: String!

  # The place’s primary email address.
  email: String

  # The place’s phone number.
  phone: String

  # The place’s external website url.
  url: String

  # A confidence rating from the geocoder.
  geoRating: Int

  # The geographical longitude of the place.
  lon: Float

  # The geographical latitude of the place.
  lat: Float

  # The geographical street number of the place.
  streetNumber: Int

  # The geographical street name of the place.
  streetName: String

  # The geographical street type of the place.
  streetType: String

  # The city of the place.
  city: String

  # The geographical state of the place.
  state: String

  # The zip code of the place.
  zip: String

  # The time this object was created.
  createdAt: Datetime

  # The time this object was last updated.
  updatedAt: Datetime
}

# Represents an update to a `Place`. Fields that are set will be updated.
input PlacePatch {
  # The unique identifier for the place.
  rowId: UUID

  # The unique identifier for the user who owns the place.
  ownerId: UUID

  # The name of the person responsible for the place listing. This is a fallback for not having a registered user as owner id.
  ownerName: String

  # The place’s human-readable name.
  name: String

  # The place’s primary email address.
  email: String

  # The place’s phone number.
  phone: String

  # The place’s external website url.
  url: String

  # A confidence rating from the geocoder.
  geoRating: Int

  # The geographical longitude of the place.
  lon: Float

  # The geographical latitude of the place.
  lat: Float

  # The geographical street number of the place.
  streetNumber: Int

  # The geographical street name of the place.
  streetName: String

  # The geographical street type of the place.
  streetType: String

  # The city of the place.
  city: String

  # The geographical state of the place.
  state: String

  # The zip code of the place.
  zip: String

  # The time this object was created.
  createdAt: Datetime

  # The time this object was last updated.
  updatedAt: Datetime
}

# A connection to a list of `Place` values.
type PlacesConnection {
  # A list of `Place` objects.
  nodes: [Place]!

  # A list of edges which contains the `Place` and cursor to aid in pagination.
  edges: [PlacesEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Place` you could get from the connection.
  totalCount: Int
}

# A `Place` edge in the connection.
type PlacesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Place` at the end of the edge.
  node: Place!
}

# Methods to use when ordering `Place`.
enum PlacesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  OWNER_ID_ASC
  OWNER_ID_DESC
  OWNER_NAME_ASC
  OWNER_NAME_DESC
  NAME_ASC
  NAME_DESC
  EMAIL_ASC
  EMAIL_DESC
  PHONE_ASC
  PHONE_DESC
  URL_ASC
  URL_DESC
  GEO_RATING_ASC
  GEO_RATING_DESC
  LON_ASC
  LON_DESC
  LAT_ASC
  LAT_DESC
  STREET_NUMBER_ASC
  STREET_NUMBER_DESC
  STREET_NAME_ASC
  STREET_NAME_DESC
  STREET_TYPE_ASC
  STREET_TYPE_DESC
  CITY_ASC
  CITY_DESC
  STATE_ASC
  STATE_DESC
  ZIP_ASC
  ZIP_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

# A preset group of food selections for convenience with recurring meals, shopping lists, etc..
type Preset implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # The unique identifier for the preset.
  rowId: UUID!

  # The unique identifier for the person.
  userId: UUID!

  # The unique identifier for the message where the user created the preset.
  messageId: UUID

  # A name for the preset which is unique per user id so it can be conveniently referenced.
  name: String

  # The time this object was created.
  createdAt: Datetime

  # Reads a single `User` that is related to this `Preset`.
  userByUserId: User!

  # Reads a single `Message` that is related to this `Preset`.
  messageByMessageId: Message

  # Reads and enables pagination through a set of `FoodSelection`.
  foodSelectionsByInheritsFromId(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `FoodSelection`.
    orderBy: FoodSelectionsOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: FoodSelectionCondition
  ): FoodSelectionsConnection!

  # Reads and enables pagination through a set of `PresetSelection`.
  presetSelectionsByPresetId(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `PresetSelection`.
    orderBy: PresetSelectionsOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: PresetSelectionCondition
  ): PresetSelectionsConnection!
}

# A condition to be used against `Preset` object types. All fields are tested for equality and combined with a logical ‘and.’
input PresetCondition {
  # Checks for equality with the object’s `rowId` field.
  rowId: UUID

  # Checks for equality with the object’s `userId` field.
  userId: UUID

  # Checks for equality with the object’s `messageId` field.
  messageId: UUID

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime
}

# An input for mutations affecting `Preset`
input PresetInput {
  # The unique identifier for the preset.
  rowId: UUID

  # The unique identifier for the person.
  userId: UUID!

  # The unique identifier for the message where the user created the preset.
  messageId: UUID

  # A name for the preset which is unique per user id so it can be conveniently referenced.
  name: String

  # The time this object was created.
  createdAt: Datetime
}

# Represents an update to a `Preset`. Fields that are set will be updated.
input PresetPatch {
  # The unique identifier for the preset.
  rowId: UUID

  # The unique identifier for the person.
  userId: UUID

  # The unique identifier for the message where the user created the preset.
  messageId: UUID

  # A name for the preset which is unique per user id so it can be conveniently referenced.
  name: String

  # The time this object was created.
  createdAt: Datetime
}

# A connection to a list of `Preset` values.
type PresetsConnection {
  # A list of `Preset` objects.
  nodes: [Preset]!

  # A list of edges which contains the `Preset` and cursor to aid in pagination.
  edges: [PresetsEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Preset` you could get from the connection.
  totalCount: Int
}

# A `Preset` edge in the connection.
type PresetsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Preset` at the end of the edge.
  node: Preset!
}

# A support table that connects a food selection to a named preset.
type PresetSelection implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # The unique identifier for the preset.
  presetId: UUID!

  # The unique identifier for the food selection.
  selectionId: UUID!

  # The time this object was created.
  createdAt: Datetime

  # Reads a single `Preset` that is related to this `PresetSelection`.
  presetByPresetId: Preset!

  # Reads a single `FoodSelection` that is related to this `PresetSelection`.
  foodSelectionBySelectionId: FoodSelection!
}

# A condition to be used against `PresetSelection` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input PresetSelectionCondition {
  # Checks for equality with the object’s `presetId` field.
  presetId: UUID

  # Checks for equality with the object’s `selectionId` field.
  selectionId: UUID

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime
}

# An input for mutations affecting `PresetSelection`
input PresetSelectionInput {
  # The unique identifier for the preset.
  presetId: UUID!

  # The unique identifier for the food selection.
  selectionId: UUID!

  # The time this object was created.
  createdAt: Datetime
}

# Represents an update to a `PresetSelection`. Fields that are set will be updated.
input PresetSelectionPatch {
  # The unique identifier for the preset.
  presetId: UUID

  # The unique identifier for the food selection.
  selectionId: UUID

  # The time this object was created.
  createdAt: Datetime
}

# A connection to a list of `PresetSelection` values.
type PresetSelectionsConnection {
  # A list of `PresetSelection` objects.
  nodes: [PresetSelection]!

  # A list of edges which contains the `PresetSelection` and cursor to aid in pagination.
  edges: [PresetSelectionsEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `PresetSelection` you could get from the connection.
  totalCount: Int
}

# A `PresetSelection` edge in the connection.
type PresetSelectionsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `PresetSelection` at the end of the edge.
  node: PresetSelection!
}

# Methods to use when ordering `PresetSelection`.
enum PresetSelectionsOrderBy {
  NATURAL
  PRESET_ID_ASC
  PRESET_ID_DESC
  SELECTION_ID_ASC
  SELECTION_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

# Methods to use when ordering `Preset`.
enum PresetsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  MESSAGE_ID_ASC
  MESSAGE_ID_DESC
  NAME_ASC
  NAME_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

# The root query type which gives access points into the data universe.
type Query implements Node {
  # Exposes the root query type nested one level down. This is helpful for Relay 1
  # which can only query top level fields if they are in a particular form.
  query: Query!

  # The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  id: ID!

  # Fetches an object given its globally unique `ID`.
  node(
    # The globally unique `ID`.
    id: ID!
  ): Node

  # Reads and enables pagination through a set of `Brand`.
  allBrands(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `Brand`.
    orderBy: BrandsOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: BrandCondition
  ): BrandsConnection

  # Reads and enables pagination through a set of `Conversation`.
  allConversations(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `Conversation`.
    orderBy: ConversationsOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: ConversationCondition
  ): ConversationsConnection

  # Reads and enables pagination through a set of `Food`.
  allFoods(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `Food`.
    orderBy: FoodsOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: FoodCondition
  ): FoodsConnection

  # Reads and enables pagination through a set of `FoodGroup`.
  allFoodGroups(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `FoodGroup`.
    orderBy: FoodGroupsOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: FoodGroupCondition
  ): FoodGroupsConnection

  # Reads and enables pagination through a set of `FoodNutrient`.
  allFoodNutrients(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `FoodNutrient`.
    orderBy: FoodNutrientsOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: FoodNutrientCondition
  ): FoodNutrientsConnection

  # Reads and enables pagination through a set of `FoodSelection`.
  allFoodSelections(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `FoodSelection`.
    orderBy: FoodSelectionsOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: FoodSelectionCondition
  ): FoodSelectionsConnection

  # Reads and enables pagination through a set of `MassConversion`.
  allMassConversions(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `MassConversion`.
    orderBy: MassConversionsOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: MassConversionCondition
  ): MassConversionsConnection

  # Reads and enables pagination through a set of `Message`.
  allMessages(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `Message`.
    orderBy: MessagesOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: MessageCondition
  ): MessagesConnection

  # Reads and enables pagination through a set of `Nutrient`.
  allNutrients(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `Nutrient`.
    orderBy: NutrientsOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: NutrientCondition
  ): NutrientsConnection

  # Reads and enables pagination through a set of `Place`.
  allPlaces(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `Place`.
    orderBy: PlacesOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: PlaceCondition
  ): PlacesConnection

  # Reads and enables pagination through a set of `Preset`.
  allPresets(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `Preset`.
    orderBy: PresetsOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: PresetCondition
  ): PresetsConnection

  # Reads and enables pagination through a set of `PresetSelection`.
  allPresetSelections(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `PresetSelection`.
    orderBy: PresetSelectionsOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: PresetSelectionCondition
  ): PresetSelectionsConnection

  # Reads and enables pagination through a set of `UnitOfMeasure`.
  allUnitOfMeasures(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `UnitOfMeasure`.
    orderBy: UnitOfMeasuresOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: UnitOfMeasureCondition
  ): UnitOfMeasuresConnection

  # Reads and enables pagination through a set of `User`.
  allUsers(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `User`.
    orderBy: UsersOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: UserCondition
  ): UsersConnection
  brandByRowId(rowId: UUID!): Brand
  brandByName(name: String!): Brand
  brandByEmail(email: String!): Brand
  brandByPhone(phone: String!): Brand
  conversationByRowId(rowId: UUID!): Conversation
  foodByRowId(rowId: Float!): Food
  foodGroupByRowId(rowId: Float!): FoodGroup
  foodNutrientByFoodIdAndNutrientId(foodId: Float!, nutrientId: Float!): FoodNutrient
  foodSelectionByRowId(rowId: UUID!): FoodSelection
  massConversionByRowId(rowId: Int!): MassConversion
  massConversionByFoodIdAndUnitOfMeasureIdAndPhysicalModDescription(foodId: Float!, unitOfMeasureId: Int!, physicalModDescription: String!): MassConversion
  messageByRowId(rowId: UUID!): Message
  nutrientByRowId(rowId: Float!): Nutrient
  placeByRowId(rowId: UUID!): Place
  placeByName(name: String!): Place
  presetByRowId(rowId: UUID!): Preset
  presetByUserIdAndName(userId: UUID!, name: String!): Preset
  presetSelectionByPresetIdAndSelectionId(presetId: UUID!, selectionId: UUID!): PresetSelection
  unitOfMeasureByRowId(rowId: Int!): UnitOfMeasure
  unitOfMeasureByFullName(fullName: String!): UnitOfMeasure
  unitOfMeasureByShortName(shortName: String!): UnitOfMeasure
  unitOfMeasureByUsdaKey(usdaKey: String!): UnitOfMeasure
  userByRowId(rowId: UUID!): User
  userByPhone(phone: String!): User

  # Gets the person who was identified by our JWT.
  currentPerson: User

  # Returns a set of possible food matches for a food selection.
  foodMatchesForSelection(
    foodSelectionId: UUID!

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor
  ): FoodsConnection!

  # Returns a geocoded result from an address
  geocoder(address: String): GeocodeResult

  # Returns a set of foods based on text search.
  searchFoods(
    foodId: Float
    foodDescription: String

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor
  ): FoodsConnection!

  # Reads a single `Brand` using its globally unique `ID`.
  brand(
    # The globally unique `ID` to be used in selecting a single `Brand`.
    id: ID!
  ): Brand

  # Reads a single `Conversation` using its globally unique `ID`.
  conversation(
    # The globally unique `ID` to be used in selecting a single `Conversation`.
    id: ID!
  ): Conversation

  # Reads a single `Food` using its globally unique `ID`.
  food(
    # The globally unique `ID` to be used in selecting a single `Food`.
    id: ID!
  ): Food

  # Reads a single `FoodGroup` using its globally unique `ID`.
  foodGroup(
    # The globally unique `ID` to be used in selecting a single `FoodGroup`.
    id: ID!
  ): FoodGroup

  # Reads a single `FoodNutrient` using its globally unique `ID`.
  foodNutrient(
    # The globally unique `ID` to be used in selecting a single `FoodNutrient`.
    id: ID!
  ): FoodNutrient

  # Reads a single `FoodSelection` using its globally unique `ID`.
  foodSelection(
    # The globally unique `ID` to be used in selecting a single `FoodSelection`.
    id: ID!
  ): FoodSelection

  # Reads a single `MassConversion` using its globally unique `ID`.
  massConversion(
    # The globally unique `ID` to be used in selecting a single `MassConversion`.
    id: ID!
  ): MassConversion

  # Reads a single `Message` using its globally unique `ID`.
  message(
    # The globally unique `ID` to be used in selecting a single `Message`.
    id: ID!
  ): Message

  # Reads a single `Nutrient` using its globally unique `ID`.
  nutrient(
    # The globally unique `ID` to be used in selecting a single `Nutrient`.
    id: ID!
  ): Nutrient

  # Reads a single `Place` using its globally unique `ID`.
  place(
    # The globally unique `ID` to be used in selecting a single `Place`.
    id: ID!
  ): Place

  # Reads a single `Preset` using its globally unique `ID`.
  preset(
    # The globally unique `ID` to be used in selecting a single `Preset`.
    id: ID!
  ): Preset

  # Reads a single `PresetSelection` using its globally unique `ID`.
  presetSelection(
    # The globally unique `ID` to be used in selecting a single `PresetSelection`.
    id: ID!
  ): PresetSelection

  # Reads a single `UnitOfMeasure` using its globally unique `ID`.
  unitOfMeasure(
    # The globally unique `ID` to be used in selecting a single `UnitOfMeasure`.
    id: ID!
  ): UnitOfMeasure

  # Reads a single `User` using its globally unique `ID`.
  user(
    # The globally unique `ID` to be used in selecting a single `User`.
    id: ID!
  ): User
}

# All input for the `registerUser` mutation.
input RegisterUserInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  name: String!
  phone: String!
  address: String!
}

# The output of our `registerUser` mutation.
type RegisterUserPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  authenticateUserResult: AuthenticateUserResult

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# The exact time of day, does not include the date. May or may not have a timezone offset.
scalar Time

# A unit of measure used to quantify a food selection.
type UnitOfMeasure implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # The unique identifier for the unit of measure.
  rowId: Int!

  # The full name of the unit of measure, e.x. cup, milliliter, gram, whole.
  fullName: String

  # The abbreviated or shortened name for the unit of measure, which matches
  # API.AI systems entities for unit-weight and unit-volume.
  shortName: String

  # A support column for resolving duplicates and typos from units referenced in the USDA NDB.
  shortNameRef: String

  # The original unique string from the USDA NDB for a unit of measure. Typos and
  # inconsistent plurals and abbreviations led to duplicated entries of the same
  # unit (e.x. cup, cups, and c). This column preserves those unique references.
  usdaKey: String
  category: UnitOfMeasureCategory

  # The number to multiply by to convert the unit into an International System of
  # Units base equivalent. Converts mass to grams, volume to liters, energy to
  # gram calories, length to meters, and temperature to celsius. Does not apply to
  # convenience, count, or time units.
  siFactor: Float

  # Reads a single `UnitOfMeasure` that is related to this `UnitOfMeasure`.
  unitOfMeasureByShortNameRef: UnitOfMeasure

  # Reads and enables pagination through a set of `UnitOfMeasure`.
  unitOfMeasuresByShortNameRef(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `UnitOfMeasure`.
    orderBy: UnitOfMeasuresOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: UnitOfMeasureCondition
  ): UnitOfMeasuresConnection!

  # Reads and enables pagination through a set of `FoodSelection`.
  foodSelectionsByUnitOfMeasureId(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `FoodSelection`.
    orderBy: FoodSelectionsOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: FoodSelectionCondition
  ): FoodSelectionsConnection!

  # Reads and enables pagination through a set of `MassConversion`.
  massConversionsByUnitOfMeasureId(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `MassConversion`.
    orderBy: MassConversionsOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: MassConversionCondition
  ): MassConversionsConnection!

  # Reads and enables pagination through a set of `Nutrient`.
  nutrientsByUnitOfMeasureUsdaKey(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `Nutrient`.
    orderBy: NutrientsOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: NutrientCondition
  ): NutrientsConnection!
}

# The category of unit of measure. Convenience is used for USDA serving size units
# that are a preset amount like 3/4 cup. Count is when the unit is an item like 1
# drumstick or 1 slice of pizza.
enum UnitOfMeasureCategory {
  CONVENIENCE
  COUNT
  ENERGY
  LENGTH
  MASS
  TEMPERATURE
  TIME
  VOLUME
}

# A condition to be used against `UnitOfMeasure` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input UnitOfMeasureCondition {
  # Checks for equality with the object’s `rowId` field.
  rowId: Int

  # Checks for equality with the object’s `fullName` field.
  fullName: String

  # Checks for equality with the object’s `shortName` field.
  shortName: String

  # Checks for equality with the object’s `shortNameRef` field.
  shortNameRef: String

  # Checks for equality with the object’s `usdaKey` field.
  usdaKey: String

  # Checks for equality with the object’s `category` field.
  category: UnitOfMeasureCategory

  # Checks for equality with the object’s `siFactor` field.
  siFactor: Float
}

# An input for mutations affecting `UnitOfMeasure`
input UnitOfMeasureInput {
  # The unique identifier for the unit of measure.
  rowId: Int

  # The full name of the unit of measure, e.x. cup, milliliter, gram, whole.
  fullName: String

  # The abbreviated or shortened name for the unit of measure, which matches
  # API.AI systems entities for unit-weight and unit-volume.
  shortName: String

  # A support column for resolving duplicates and typos from units referenced in the USDA NDB.
  shortNameRef: String

  # The original unique string from the USDA NDB for a unit of measure. Typos and
  # inconsistent plurals and abbreviations led to duplicated entries of the same
  # unit (e.x. cup, cups, and c). This column preserves those unique references.
  usdaKey: String
  category: UnitOfMeasureCategory

  # The number to multiply by to convert the unit into an International System of
  # Units base equivalent. Converts mass to grams, volume to liters, energy to
  # gram calories, length to meters, and temperature to celsius. Does not apply to
  # convenience, count, or time units.
  siFactor: Float
}

# Represents an update to a `UnitOfMeasure`. Fields that are set will be updated.
input UnitOfMeasurePatch {
  # The unique identifier for the unit of measure.
  rowId: Int

  # The full name of the unit of measure, e.x. cup, milliliter, gram, whole.
  fullName: String

  # The abbreviated or shortened name for the unit of measure, which matches
  # API.AI systems entities for unit-weight and unit-volume.
  shortName: String

  # A support column for resolving duplicates and typos from units referenced in the USDA NDB.
  shortNameRef: String

  # The original unique string from the USDA NDB for a unit of measure. Typos and
  # inconsistent plurals and abbreviations led to duplicated entries of the same
  # unit (e.x. cup, cups, and c). This column preserves those unique references.
  usdaKey: String
  category: UnitOfMeasureCategory

  # The number to multiply by to convert the unit into an International System of
  # Units base equivalent. Converts mass to grams, volume to liters, energy to
  # gram calories, length to meters, and temperature to celsius. Does not apply to
  # convenience, count, or time units.
  siFactor: Float
}

# A connection to a list of `UnitOfMeasure` values.
type UnitOfMeasuresConnection {
  # A list of `UnitOfMeasure` objects.
  nodes: [UnitOfMeasure]!

  # A list of edges which contains the `UnitOfMeasure` and cursor to aid in pagination.
  edges: [UnitOfMeasuresEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `UnitOfMeasure` you could get from the connection.
  totalCount: Int
}

# A `UnitOfMeasure` edge in the connection.
type UnitOfMeasuresEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `UnitOfMeasure` at the end of the edge.
  node: UnitOfMeasure!
}

# Methods to use when ordering `UnitOfMeasure`.
enum UnitOfMeasuresOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  FULL_NAME_ASC
  FULL_NAME_DESC
  SHORT_NAME_ASC
  SHORT_NAME_DESC
  SHORT_NAME_REF_ASC
  SHORT_NAME_REF_DESC
  USDA_KEY_ASC
  USDA_KEY_DESC
  CATEGORY_ASC
  CATEGORY_DESC
  SI_FACTOR_ASC
  SI_FACTOR_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

# All input for the `updateBrandByEmail` mutation.
input UpdateBrandByEmailInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `Brand` being updated.
  brandPatch: BrandPatch!
  email: String!
}

# All input for the `updateBrandByName` mutation.
input UpdateBrandByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `Brand` being updated.
  brandPatch: BrandPatch!
  name: String!
}

# All input for the `updateBrandByPhone` mutation.
input UpdateBrandByPhoneInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `Brand` being updated.
  brandPatch: BrandPatch!
  phone: String!
}

# All input for the `updateBrandByRowId` mutation.
input UpdateBrandByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `Brand` being updated.
  brandPatch: BrandPatch!
  rowId: UUID!
}

# All input for the `updateBrand` mutation.
input UpdateBrandInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Brand` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `Brand` being updated.
  brandPatch: BrandPatch!
}

# The output of our update `Brand` mutation.
type UpdateBrandPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Brand` that was updated by this mutation.
  brand: Brand

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `User` that is related to this `Brand`.
  userByOwnerId: User

  # An edge for the type. May be used by Relay 1.
  brandEdge(
    # The method to use when ordering `Brand`.
    orderBy: BrandsOrderBy = PRIMARY_KEY_ASC
  ): BrandsEdge
}

# All input for the `updateConversationByRowId` mutation.
input UpdateConversationByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `Conversation` being updated.
  conversationPatch: ConversationPatch!
  rowId: UUID!
}

# All input for the `updateConversation` mutation.
input UpdateConversationInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Conversation` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `Conversation` being updated.
  conversationPatch: ConversationPatch!
}

# The output of our update `Conversation` mutation.
type UpdateConversationPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Conversation` that was updated by this mutation.
  conversation: Conversation

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `User` that is related to this `Conversation`.
  userByUserId: User

  # An edge for the type. May be used by Relay 1.
  conversationEdge(
    # The method to use when ordering `Conversation`.
    orderBy: ConversationsOrderBy = PRIMARY_KEY_ASC
  ): ConversationsEdge
}

# All input for the `updateFoodByRowId` mutation.
input UpdateFoodByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `Food` being updated.
  foodPatch: FoodPatch!
  rowId: Float!
}

# All input for the `updateFoodGroupByRowId` mutation.
input UpdateFoodGroupByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `FoodGroup` being updated.
  foodGroupPatch: FoodGroupPatch!
  rowId: Float!
}

# All input for the `updateFoodGroup` mutation.
input UpdateFoodGroupInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `FoodGroup` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `FoodGroup` being updated.
  foodGroupPatch: FoodGroupPatch!
}

# The output of our update `FoodGroup` mutation.
type UpdateFoodGroupPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `FoodGroup` that was updated by this mutation.
  foodGroup: FoodGroup

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # An edge for the type. May be used by Relay 1.
  foodGroupEdge(
    # The method to use when ordering `FoodGroup`.
    orderBy: FoodGroupsOrderBy = PRIMARY_KEY_ASC
  ): FoodGroupsEdge
}

# All input for the `updateFood` mutation.
input UpdateFoodInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Food` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `Food` being updated.
  foodPatch: FoodPatch!
}

# All input for the `updateFoodNutrientByFoodIdAndNutrientId` mutation.
input UpdateFoodNutrientByFoodIdAndNutrientIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `FoodNutrient` being updated.
  foodNutrientPatch: FoodNutrientPatch!
  foodId: Float!
  nutrientId: Float!
}

# All input for the `updateFoodNutrient` mutation.
input UpdateFoodNutrientInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `FoodNutrient` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `FoodNutrient` being updated.
  foodNutrientPatch: FoodNutrientPatch!
}

# The output of our update `FoodNutrient` mutation.
type UpdateFoodNutrientPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `FoodNutrient` that was updated by this mutation.
  foodNutrient: FoodNutrient

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Food` that is related to this `FoodNutrient`.
  foodByFoodId: Food

  # Reads a single `Nutrient` that is related to this `FoodNutrient`.
  nutrientByNutrientId: Nutrient

  # Reads a single `User` that is related to this `FoodNutrient`.
  userByUserId: User

  # An edge for the type. May be used by Relay 1.
  foodNutrientEdge(
    # The method to use when ordering `FoodNutrient`.
    orderBy: FoodNutrientsOrderBy = PRIMARY_KEY_ASC
  ): FoodNutrientsEdge
}

# The output of our update `Food` mutation.
type UpdateFoodPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Food` that was updated by this mutation.
  food: Food

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `FoodGroup` that is related to this `Food`.
  foodGroupByFoodGroupId: FoodGroup

  # Reads a single `Brand` that is related to this `Food`.
  brandByBrandName: Brand

  # Reads a single `User` that is related to this `Food`.
  userByUserId: User

  # An edge for the type. May be used by Relay 1.
  foodEdge(
    # The method to use when ordering `Food`.
    orderBy: FoodsOrderBy = PRIMARY_KEY_ASC
  ): FoodsEdge
}

# All input for the `updateFoodSelectionByRowId` mutation.
input UpdateFoodSelectionByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `FoodSelection` being updated.
  foodSelectionPatch: FoodSelectionPatch!
  rowId: UUID!
}

# All input for the `updateFoodSelection` mutation.
input UpdateFoodSelectionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `FoodSelection` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `FoodSelection` being updated.
  foodSelectionPatch: FoodSelectionPatch!
}

# The output of our update `FoodSelection` mutation.
type UpdateFoodSelectionPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `FoodSelection` that was updated by this mutation.
  foodSelection: FoodSelection

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `User` that is related to this `FoodSelection`.
  userByUserId: User

  # Reads a single `Message` that is related to this `FoodSelection`.
  messageByMessageId: Message

  # Reads a single `Preset` that is related to this `FoodSelection`.
  presetByInheritsFromId: Preset

  # Reads a single `Food` that is related to this `FoodSelection`.
  foodByFoodId: Food

  # Reads a single `UnitOfMeasure` that is related to this `FoodSelection`.
  unitOfMeasureByUnitOfMeasureId: UnitOfMeasure

  # An edge for the type. May be used by Relay 1.
  foodSelectionEdge(
    # The method to use when ordering `FoodSelection`.
    orderBy: FoodSelectionsOrderBy = PRIMARY_KEY_ASC
  ): FoodSelectionsEdge
}

# All input for the `updateMassConversionByFoodIdAndUnitOfMeasureIdAndPhysicalModDescription` mutation.
input UpdateMassConversionByFoodIdAndUnitOfMeasureIdAndPhysicalModDescriptionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `MassConversion` being updated.
  massConversionPatch: MassConversionPatch!
  foodId: Float!
  unitOfMeasureId: Int!
  physicalModDescription: String!
}

# All input for the `updateMassConversionByRowId` mutation.
input UpdateMassConversionByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `MassConversion` being updated.
  massConversionPatch: MassConversionPatch!
  rowId: Int!
}

# All input for the `updateMassConversion` mutation.
input UpdateMassConversionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `MassConversion` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `MassConversion` being updated.
  massConversionPatch: MassConversionPatch!
}

# The output of our update `MassConversion` mutation.
type UpdateMassConversionPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `MassConversion` that was updated by this mutation.
  massConversion: MassConversion

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Food` that is related to this `MassConversion`.
  foodByFoodId: Food

  # Reads a single `UnitOfMeasure` that is related to this `MassConversion`.
  unitOfMeasureByUnitOfMeasureId: UnitOfMeasure

  # Reads a single `User` that is related to this `MassConversion`.
  userByUserId: User

  # An edge for the type. May be used by Relay 1.
  massConversionEdge(
    # The method to use when ordering `MassConversion`.
    orderBy: MassConversionsOrderBy = PRIMARY_KEY_ASC
  ): MassConversionsEdge
}

# All input for the `updateMessageByRowId` mutation.
input UpdateMessageByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `Message` being updated.
  messagePatch: MessagePatch!
  rowId: UUID!
}

# All input for the `updateMessage` mutation.
input UpdateMessageInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Message` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `Message` being updated.
  messagePatch: MessagePatch!
}

# The output of our update `Message` mutation.
type UpdateMessagePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Message` that was updated by this mutation.
  message: Message

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Conversation` that is related to this `Message`.
  conversationByConversationId: Conversation

  # An edge for the type. May be used by Relay 1.
  messageEdge(
    # The method to use when ordering `Message`.
    orderBy: MessagesOrderBy = PRIMARY_KEY_ASC
  ): MessagesEdge
}

# All input for the `updateNutrientByRowId` mutation.
input UpdateNutrientByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `Nutrient` being updated.
  nutrientPatch: NutrientPatch!
  rowId: Float!
}

# All input for the `updateNutrient` mutation.
input UpdateNutrientInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Nutrient` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `Nutrient` being updated.
  nutrientPatch: NutrientPatch!
}

# The output of our update `Nutrient` mutation.
type UpdateNutrientPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Nutrient` that was updated by this mutation.
  nutrient: Nutrient

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `UnitOfMeasure` that is related to this `Nutrient`.
  unitOfMeasureByUnitOfMeasureUsdaKey: UnitOfMeasure

  # An edge for the type. May be used by Relay 1.
  nutrientEdge(
    # The method to use when ordering `Nutrient`.
    orderBy: NutrientsOrderBy = PRIMARY_KEY_ASC
  ): NutrientsEdge
}

# All input for the `updatePlaceByName` mutation.
input UpdatePlaceByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `Place` being updated.
  placePatch: PlacePatch!
  name: String!
}

# All input for the `updatePlaceByRowId` mutation.
input UpdatePlaceByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `Place` being updated.
  placePatch: PlacePatch!
  rowId: UUID!
}

# All input for the `updatePlace` mutation.
input UpdatePlaceInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Place` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `Place` being updated.
  placePatch: PlacePatch!
}

# The output of our update `Place` mutation.
type UpdatePlacePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Place` that was updated by this mutation.
  place: Place

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `User` that is related to this `Place`.
  userByOwnerId: User

  # An edge for the type. May be used by Relay 1.
  placeEdge(
    # The method to use when ordering `Place`.
    orderBy: PlacesOrderBy = PRIMARY_KEY_ASC
  ): PlacesEdge
}

# All input for the `updatePresetByRowId` mutation.
input UpdatePresetByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `Preset` being updated.
  presetPatch: PresetPatch!
  rowId: UUID!
}

# All input for the `updatePresetByUserIdAndName` mutation.
input UpdatePresetByUserIdAndNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `Preset` being updated.
  presetPatch: PresetPatch!
  userId: UUID!
  name: String!
}

# All input for the `updatePreset` mutation.
input UpdatePresetInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Preset` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `Preset` being updated.
  presetPatch: PresetPatch!
}

# The output of our update `Preset` mutation.
type UpdatePresetPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Preset` that was updated by this mutation.
  preset: Preset

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `User` that is related to this `Preset`.
  userByUserId: User

  # Reads a single `Message` that is related to this `Preset`.
  messageByMessageId: Message

  # An edge for the type. May be used by Relay 1.
  presetEdge(
    # The method to use when ordering `Preset`.
    orderBy: PresetsOrderBy = PRIMARY_KEY_ASC
  ): PresetsEdge
}

# All input for the `updatePresetSelectionByPresetIdAndSelectionId` mutation.
input UpdatePresetSelectionByPresetIdAndSelectionIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `PresetSelection` being updated.
  presetSelectionPatch: PresetSelectionPatch!
  presetId: UUID!
  selectionId: UUID!
}

# All input for the `updatePresetSelection` mutation.
input UpdatePresetSelectionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `PresetSelection` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `PresetSelection` being updated.
  presetSelectionPatch: PresetSelectionPatch!
}

# The output of our update `PresetSelection` mutation.
type UpdatePresetSelectionPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `PresetSelection` that was updated by this mutation.
  presetSelection: PresetSelection

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `Preset` that is related to this `PresetSelection`.
  presetByPresetId: Preset

  # Reads a single `FoodSelection` that is related to this `PresetSelection`.
  foodSelectionBySelectionId: FoodSelection

  # An edge for the type. May be used by Relay 1.
  presetSelectionEdge(
    # The method to use when ordering `PresetSelection`.
    orderBy: PresetSelectionsOrderBy = PRIMARY_KEY_ASC
  ): PresetSelectionsEdge
}

# All input for the `updateUnitOfMeasureByFullName` mutation.
input UpdateUnitOfMeasureByFullNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `UnitOfMeasure` being updated.
  unitOfMeasurePatch: UnitOfMeasurePatch!
  fullName: String!
}

# All input for the `updateUnitOfMeasureByRowId` mutation.
input UpdateUnitOfMeasureByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `UnitOfMeasure` being updated.
  unitOfMeasurePatch: UnitOfMeasurePatch!
  rowId: Int!
}

# All input for the `updateUnitOfMeasureByShortName` mutation.
input UpdateUnitOfMeasureByShortNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `UnitOfMeasure` being updated.
  unitOfMeasurePatch: UnitOfMeasurePatch!
  shortName: String!
}

# All input for the `updateUnitOfMeasureByUsdaKey` mutation.
input UpdateUnitOfMeasureByUsdaKeyInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `UnitOfMeasure` being updated.
  unitOfMeasurePatch: UnitOfMeasurePatch!
  usdaKey: String!
}

# All input for the `updateUnitOfMeasure` mutation.
input UpdateUnitOfMeasureInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `UnitOfMeasure` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `UnitOfMeasure` being updated.
  unitOfMeasurePatch: UnitOfMeasurePatch!
}

# The output of our update `UnitOfMeasure` mutation.
type UpdateUnitOfMeasurePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `UnitOfMeasure` that was updated by this mutation.
  unitOfMeasure: UnitOfMeasure

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # Reads a single `UnitOfMeasure` that is related to this `UnitOfMeasure`.
  unitOfMeasureByShortNameRef: UnitOfMeasure

  # An edge for the type. May be used by Relay 1.
  unitOfMeasureEdge(
    # The method to use when ordering `UnitOfMeasure`.
    orderBy: UnitOfMeasuresOrderBy = PRIMARY_KEY_ASC
  ): UnitOfMeasuresEdge
}

# All input for the `updateUserByPhone` mutation.
input UpdateUserByPhoneInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `User` being updated.
  userPatch: UserPatch!
  phone: String!
}

# All input for the `updateUserByRowId` mutation.
input UpdateUserByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # An object where the defined keys will be set on the `User` being updated.
  userPatch: UserPatch!
  rowId: UUID!
}

# All input for the `updateUser` mutation.
input UpdateUserInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `User` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `User` being updated.
  userPatch: UserPatch!
}

# The output of our update `User` mutation.
type UpdateUserPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `User` that was updated by this mutation.
  user: User

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query

  # An edge for the type. May be used by Relay 1.
  userEdge(
    # The method to use when ordering `User`.
    orderBy: UsersOrderBy = PRIMARY_KEY_ASC
  ): UsersEdge
}

# A single human that uses the Terrafarm CSA app.
type User implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # The user’s unique identifier.
  rowId: UUID!

  # A human-readable first and last name.
  name: String

  # A phone number. Phone numbers must be unique across all users and must match the E.164 numbering spec.
  phone: String!

  # A confidence rating from the geocoder.
  geoRating: Int

  # The geographical longitude of the user.
  lon: Float

  # The geographical latitude of the user.
  lat: Float

  # The geographical street number of the user.
  streetNumber: Int

  # The geographical street name of the user.
  streetName: String

  # The geographical street type of the user.
  streetType: String

  # The city of the user.
  city: String

  # The geographical state of the user.
  state: String

  # The zip code of the user.
  zip: String

  # The time this object was created.
  createdAt: Datetime

  # The time this object was last updated.
  updatedAt: Datetime

  # Reads and enables pagination through a set of `Conversation`.
  conversationsByUserId(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `Conversation`.
    orderBy: ConversationsOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: ConversationCondition
  ): ConversationsConnection!

  # Reads and enables pagination through a set of `Place`.
  placesByOwnerId(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `Place`.
    orderBy: PlacesOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: PlaceCondition
  ): PlacesConnection!

  # Reads and enables pagination through a set of `Brand`.
  brandsByOwnerId(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `Brand`.
    orderBy: BrandsOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: BrandCondition
  ): BrandsConnection!

  # Reads and enables pagination through a set of `Food`.
  foodsByUserId(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `Food`.
    orderBy: FoodsOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: FoodCondition
  ): FoodsConnection!

  # Reads and enables pagination through a set of `Preset`.
  presetsByUserId(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `Preset`.
    orderBy: PresetsOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: PresetCondition
  ): PresetsConnection!

  # Reads and enables pagination through a set of `FoodSelection`.
  foodSelectionsByUserId(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `FoodSelection`.
    orderBy: FoodSelectionsOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: FoodSelectionCondition
  ): FoodSelectionsConnection!

  # Reads and enables pagination through a set of `MassConversion`.
  massConversionsByUserId(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `MassConversion`.
    orderBy: MassConversionsOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: MassConversionCondition
  ): MassConversionsConnection!

  # Reads and enables pagination through a set of `FoodNutrient`.
  foodNutrientsByUserId(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `FoodNutrient`.
    orderBy: FoodNutrientsOrderBy = PRIMARY_KEY_ASC

    # A condition to be used in determining which values should be returned by the collection.
    condition: FoodNutrientCondition
  ): FoodNutrientsConnection!
}

# A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’
input UserCondition {
  # Checks for equality with the object’s `rowId` field.
  rowId: UUID

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `phone` field.
  phone: String

  # Checks for equality with the object’s `geoRating` field.
  geoRating: Int

  # Checks for equality with the object’s `lon` field.
  lon: Float

  # Checks for equality with the object’s `lat` field.
  lat: Float

  # Checks for equality with the object’s `streetNumber` field.
  streetNumber: Int

  # Checks for equality with the object’s `streetName` field.
  streetName: String

  # Checks for equality with the object’s `streetType` field.
  streetType: String

  # Checks for equality with the object’s `city` field.
  city: String

  # Checks for equality with the object’s `state` field.
  state: String

  # Checks for equality with the object’s `zip` field.
  zip: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# An input for mutations affecting `User`
input UserInput {
  # The user’s unique identifier.
  rowId: UUID

  # A human-readable first and last name.
  name: String

  # A phone number. Phone numbers must be unique across all users and must match the E.164 numbering spec.
  phone: String!

  # A confidence rating from the geocoder.
  geoRating: Int

  # The geographical longitude of the user.
  lon: Float

  # The geographical latitude of the user.
  lat: Float

  # The geographical street number of the user.
  streetNumber: Int

  # The geographical street name of the user.
  streetName: String

  # The geographical street type of the user.
  streetType: String

  # The city of the user.
  city: String

  # The geographical state of the user.
  state: String

  # The zip code of the user.
  zip: String

  # The time this object was created.
  createdAt: Datetime

  # The time this object was last updated.
  updatedAt: Datetime
}

# Represents an update to a `User`. Fields that are set will be updated.
input UserPatch {
  # The user’s unique identifier.
  rowId: UUID

  # A human-readable first and last name.
  name: String

  # A phone number. Phone numbers must be unique across all users and must match the E.164 numbering spec.
  phone: String

  # A confidence rating from the geocoder.
  geoRating: Int

  # The geographical longitude of the user.
  lon: Float

  # The geographical latitude of the user.
  lat: Float

  # The geographical street number of the user.
  streetNumber: Int

  # The geographical street name of the user.
  streetName: String

  # The geographical street type of the user.
  streetType: String

  # The city of the user.
  city: String

  # The geographical state of the user.
  state: String

  # The zip code of the user.
  zip: String

  # The time this object was created.
  createdAt: Datetime

  # The time this object was last updated.
  updatedAt: Datetime
}

# A connection to a list of `User` values.
type UsersConnection {
  # A list of `User` objects.
  nodes: [User]!

  # A list of edges which contains the `User` and cursor to aid in pagination.
  edges: [UsersEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `User` you could get from the connection.
  totalCount: Int
}

# A `User` edge in the connection.
type UsersEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `User` at the end of the edge.
  node: User!
}

# Methods to use when ordering `User`.
enum UsersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  PHONE_ASC
  PHONE_DESC
  GEO_RATING_ASC
  GEO_RATING_DESC
  LON_ASC
  LON_DESC
  LAT_ASC
  LAT_DESC
  STREET_NUMBER_ASC
  STREET_NUMBER_DESC
  STREET_NAME_ASC
  STREET_NAME_DESC
  STREET_TYPE_ASC
  STREET_TYPE_DESC
  CITY_ASC
  CITY_DESC
  STATE_ASC
  STATE_DESC
  ZIP_ASC
  ZIP_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

# A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122).
scalar UUID
