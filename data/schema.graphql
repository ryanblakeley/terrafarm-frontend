# All input for the `authenticateUser` mutation.
input AuthenticateUserInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  phone: String!
}

# The output of our `authenticateUser` mutation.
type AuthenticateUserPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  authenticateUserResult: AuthenticateUserResult

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

type AuthenticateUserResult {
  jwtToken: JwtToken
  userId: Uuid
}

# A brand that has or sells food.
type Brand implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # The unique identifier for the brand.
  rowId: Uuid!

  # The unique identifier for the user who owns the brand.
  ownerId: Uuid

  # The name of the person responsible for the brand listing. This is a fallback for not having a registered user as owner id.
  ownerName: String

  # The brand’s human-readable name.
  name: String!

  # The brand’s primary email address.
  email: String

  # The brand’s phone number.
  phone: String

  # The brand’s external website url.
  url: String

  # The time this object was created.
  createdAt: Datetime

  # The time this object was last updated.
  updatedAt: Datetime

  # Reads a single `User` that is related to this `Brand`.
  userByOwnerId: User

  # Reads and enables pagination through a set of `Food`.
  foodsByBrandName(
    # The method to use when ordering `Food`.
    orderBy: FoodsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: FoodCondition
  ): FoodsConnection

  # Reads and enables pagination through a set of `FoodSelection`.
  foodSelectionsByBrandId(
    # The method to use when ordering `FoodSelection`.
    orderBy: FoodSelectionsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: FoodSelectionCondition
  ): FoodSelectionsConnection
}

# A condition to be used against `Brand` object types. All fields are tested for equality and combined with a logical ‘and.’
input BrandCondition {
  # Checks for equality with the object’s `rowId` field.
  rowId: Uuid

  # Checks for equality with the object’s `ownerId` field.
  ownerId: Uuid

  # Checks for equality with the object’s `ownerName` field.
  ownerName: String

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `email` field.
  email: String

  # Checks for equality with the object’s `phone` field.
  phone: String

  # Checks for equality with the object’s `url` field.
  url: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# A brand that has or sells food.
input BrandInput {
  # The unique identifier for the brand.
  rowId: Uuid

  # The unique identifier for the user who owns the brand.
  ownerId: Uuid

  # The name of the person responsible for the brand listing. This is a fallback for not having a registered user as owner id.
  ownerName: String

  # The brand’s human-readable name.
  name: String!

  # The brand’s primary email address.
  email: String

  # The brand’s phone number.
  phone: String

  # The brand’s external website url.
  url: String

  # The time this object was created.
  createdAt: Datetime

  # The time this object was last updated.
  updatedAt: Datetime
}

# Represents an update to a `Brand`. Fields that are set will be updated.
input BrandPatch {
  # The unique identifier for the brand.
  rowId: Uuid

  # The unique identifier for the user who owns the brand.
  ownerId: Uuid

  # The name of the person responsible for the brand listing. This is a fallback for not having a registered user as owner id.
  ownerName: String

  # The brand’s human-readable name.
  name: String

  # The brand’s primary email address.
  email: String

  # The brand’s phone number.
  phone: String

  # The brand’s external website url.
  url: String

  # The time this object was created.
  createdAt: Datetime

  # The time this object was last updated.
  updatedAt: Datetime
}

# A connection to a list of `Brand` values.
type BrandsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Brand` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Brand` and cursor to aid in pagination.
  edges: [BrandsEdge]

  # A list of `Brand` objects.
  nodes: [Brand!]
}

# A `Brand` edge in the connection.
type BrandsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Brand` at the end of the edge.
  node: Brand!
}

# Methods to use when ordering `Brand`.
enum BrandsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  OWNER_ID_ASC
  OWNER_ID_DESC
  OWNER_NAME_ASC
  OWNER_NAME_DESC
  NAME_ASC
  NAME_DESC
  EMAIL_ASC
  EMAIL_DESC
  PHONE_ASC
  PHONE_DESC
  URL_ASC
  URL_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

# A chemical process or activity that changes the nutrition per 100g of a food.
type ChemicalChange implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # The human-readable name of the chemical change, e.x. cooked, baked, fermented, dehydrated.
  name: String!

  # Details about the physical change, e.x. 1"x1"x2" pieces.
  description: String

  # The time this object was created.
  createdAt: Datetime

  # Reads and enables pagination through a set of `FoodSelection`.
  foodSelectionsByChemicalChangeName(
    # The method to use when ordering `FoodSelection`.
    orderBy: FoodSelectionsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: FoodSelectionCondition
  ): FoodSelectionsConnection
}

# A condition to be used against `ChemicalChange` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input ChemicalChangeCondition {
  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `description` field.
  description: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime
}

# A chemical process or activity that changes the nutrition per 100g of a food.
input ChemicalChangeInput {
  # The human-readable name of the chemical change, e.x. cooked, baked, fermented, dehydrated.
  name: String!

  # Details about the physical change, e.x. 1"x1"x2" pieces.
  description: String

  # The time this object was created.
  createdAt: Datetime
}

# Represents an update to a `ChemicalChange`. Fields that are set will be updated.
input ChemicalChangePatch {
  # The human-readable name of the chemical change, e.x. cooked, baked, fermented, dehydrated.
  name: String

  # Details about the physical change, e.x. 1"x1"x2" pieces.
  description: String

  # The time this object was created.
  createdAt: Datetime
}

# A connection to a list of `ChemicalChange` values.
type ChemicalChangesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `ChemicalChange` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `ChemicalChange` and cursor to aid in pagination.
  edges: [ChemicalChangesEdge]

  # A list of `ChemicalChange` objects.
  nodes: [ChemicalChange!]
}

# A `ChemicalChange` edge in the connection.
type ChemicalChangesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `ChemicalChange` at the end of the edge.
  node: ChemicalChange!
}

# Methods to use when ordering `ChemicalChange`.
enum ChemicalChangesOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
}

# A conversation session between a person and the agent.
type Conversation implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # The unique identifier for the conversation which is provided by the agent.
  rowId: Uuid!

  # The unique identifier for the person.
  userId: Uuid!

  # The time this object was created.
  createdAt: Datetime

  # Reads a single `User` that is related to this `Conversation`.
  userByUserId: User

  # Reads and enables pagination through a set of `Message`.
  messagesByConversationId(
    # The method to use when ordering `Message`.
    orderBy: MessagesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: MessageCondition
  ): MessagesConnection

  # Reads and enables pagination through a set of `Preset`.
  presetsByConversationId(
    # The method to use when ordering `Preset`.
    orderBy: PresetsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: PresetCondition
  ): PresetsConnection

  # Reads and enables pagination through a set of `FoodSelection`.
  foodSelectionsByConversationId(
    # The method to use when ordering `FoodSelection`.
    orderBy: FoodSelectionsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: FoodSelectionCondition
  ): FoodSelectionsConnection
}

# A condition to be used against `Conversation` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input ConversationCondition {
  # Checks for equality with the object’s `rowId` field.
  rowId: Uuid

  # Checks for equality with the object’s `userId` field.
  userId: Uuid

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime
}

# A conversation session between a person and the agent.
input ConversationInput {
  # The unique identifier for the conversation which is provided by the agent.
  rowId: Uuid

  # The unique identifier for the person.
  userId: Uuid!

  # The time this object was created.
  createdAt: Datetime
}

# Represents an update to a `Conversation`. Fields that are set will be updated.
input ConversationPatch {
  # The unique identifier for the conversation which is provided by the agent.
  rowId: Uuid

  # The unique identifier for the person.
  userId: Uuid

  # The time this object was created.
  createdAt: Datetime
}

# A connection to a list of `Conversation` values.
type ConversationsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Conversation` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Conversation` and cursor to aid in pagination.
  edges: [ConversationsEdge]

  # A list of `Conversation` objects.
  nodes: [Conversation!]
}

# A `Conversation` edge in the connection.
type ConversationsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Conversation` at the end of the edge.
  node: Conversation!
}

# Methods to use when ordering `Conversation`.
enum ConversationsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
}

# All input for the `createBrand` mutation.
input CreateBrandInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Brand` to be created by this mutation.
  brand: BrandInput!
}

# The output of our `createBrand` mutation.
type CreateBrandPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Brand` that was created by this mutation.
  brand: Brand

  # An edge for our `Brand`. May be used by Relay 1.
  brandEdge(
    # The method to use when ordering `Brand`.
    orderBy: BrandsOrderBy = PRIMARY_KEY_ASC
  ): BrandsEdge

  # Reads a single `User` that is related to this `Brand`.
  userByOwnerId: User

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createChemicalChange` mutation.
input CreateChemicalChangeInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `ChemicalChange` to be created by this mutation.
  chemicalChange: ChemicalChangeInput!
}

# The output of our `createChemicalChange` mutation.
type CreateChemicalChangePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `ChemicalChange` that was created by this mutation.
  chemicalChange: ChemicalChange

  # An edge for our `ChemicalChange`. May be used by Relay 1.
  chemicalChangeEdge(
    # The method to use when ordering `ChemicalChange`.
    orderBy: ChemicalChangesOrderBy = PRIMARY_KEY_ASC
  ): ChemicalChangesEdge

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createConversation` mutation.
input CreateConversationInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Conversation` to be created by this mutation.
  conversation: ConversationInput!
}

# The output of our `createConversation` mutation.
type CreateConversationPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Conversation` that was created by this mutation.
  conversation: Conversation

  # An edge for our `Conversation`. May be used by Relay 1.
  conversationEdge(
    # The method to use when ordering `Conversation`.
    orderBy: ConversationsOrderBy = PRIMARY_KEY_ASC
  ): ConversationsEdge

  # Reads a single `User` that is related to this `Conversation`.
  userByUserId: User

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createFoodGroup` mutation.
input CreateFoodGroupInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `FoodGroup` to be created by this mutation.
  foodGroup: FoodGroupInput!
}

# The output of our `createFoodGroup` mutation.
type CreateFoodGroupPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `FoodGroup` that was created by this mutation.
  foodGroup: FoodGroup

  # An edge for our `FoodGroup`. May be used by Relay 1.
  foodGroupEdge(
    # The method to use when ordering `FoodGroup`.
    orderBy: FoodGroupsOrderBy = PRIMARY_KEY_ASC
  ): FoodGroupsEdge

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createFood` mutation.
input CreateFoodInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Food` to be created by this mutation.
  food: FoodInput!
}

# All input for the `createFoodNutrient` mutation.
input CreateFoodNutrientInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `FoodNutrient` to be created by this mutation.
  foodNutrient: FoodNutrientInput!
}

# The output of our `createFoodNutrient` mutation.
type CreateFoodNutrientPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `FoodNutrient` that was created by this mutation.
  foodNutrient: FoodNutrient

  # An edge for our `FoodNutrient`. May be used by Relay 1.
  foodNutrientEdge(
    # The method to use when ordering `FoodNutrient`.
    orderBy: FoodNutrientsOrderBy = PRIMARY_KEY_ASC
  ): FoodNutrientsEdge

  # Reads a single `Food` that is related to this `FoodNutrient`.
  foodByFoodId: Food

  # Reads a single `Nutrient` that is related to this `FoodNutrient`.
  nutrientByNutrientId: Nutrient

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# The output of our `createFood` mutation.
type CreateFoodPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Food` that was created by this mutation.
  food: Food

  # An edge for our `Food`. May be used by Relay 1.
  foodEdge(
    # The method to use when ordering `Food`.
    orderBy: FoodsOrderBy = PRIMARY_KEY_ASC
  ): FoodsEdge

  # Reads a single `FoodGroup` that is related to this `Food`.
  foodGroupByFoodGroupId: FoodGroup

  # Reads a single `Brand` that is related to this `Food`.
  brandByBrandName: Brand

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createFoodSelection` mutation.
input CreateFoodSelectionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `FoodSelection` to be created by this mutation.
  foodSelection: FoodSelectionInput!
}

# The output of our `createFoodSelection` mutation.
type CreateFoodSelectionPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `FoodSelection` that was created by this mutation.
  foodSelection: FoodSelection

  # An edge for our `FoodSelection`. May be used by Relay 1.
  foodSelectionEdge(
    # The method to use when ordering `FoodSelection`.
    orderBy: FoodSelectionsOrderBy = PRIMARY_KEY_ASC
  ): FoodSelectionsEdge

  # Reads a single `User` that is related to this `FoodSelection`.
  userByUserId: User

  # Reads a single `Conversation` that is related to this `FoodSelection`.
  conversationByConversationId: Conversation

  # Reads a single `Preset` that is related to this `FoodSelection`.
  presetByInheritsFromId: Preset

  # Reads a single `Place` that is related to this `FoodSelection`.
  placeByPlaceId: Place

  # Reads a single `Food` that is related to this `FoodSelection`.
  foodByFoodId: Food

  # Reads a single `Brand` that is related to this `FoodSelection`.
  brandByBrandId: Brand

  # Reads a single `ChemicalChange` that is related to this `FoodSelection`.
  chemicalChangeByChemicalChangeName: ChemicalChange

  # Reads a single `PhysicalChange` that is related to this `FoodSelection`.
  physicalChangeByPhysicalChangeName: PhysicalChange

  # Reads a single `UnitOfMeasure` that is related to this `FoodSelection`.
  unitOfMeasureByUnitOfMeasureId: UnitOfMeasure

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createMassConversion` mutation.
input CreateMassConversionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `MassConversion` to be created by this mutation.
  massConversion: MassConversionInput!
}

# The output of our `createMassConversion` mutation.
type CreateMassConversionPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `MassConversion` that was created by this mutation.
  massConversion: MassConversion

  # An edge for our `MassConversion`. May be used by Relay 1.
  massConversionEdge(
    # The method to use when ordering `MassConversion`.
    orderBy: MassConversionsOrderBy = PRIMARY_KEY_ASC
  ): MassConversionsEdge

  # Reads a single `Food` that is related to this `MassConversion`.
  foodByFoodId: Food

  # Reads a single `UnitOfMeasure` that is related to this `MassConversion`.
  unitOfMeasureByUnitOfMeasureId: UnitOfMeasure

  # Reads a single `PhysicalChange` that is related to this `MassConversion`.
  physicalChangeByPhysicalChangeName: PhysicalChange

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createMessage` mutation.
input CreateMessageInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Message` to be created by this mutation.
  message: MessageInput!
}

# The output of our `createMessage` mutation.
type CreateMessagePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Message` that was created by this mutation.
  message: Message

  # An edge for our `Message`. May be used by Relay 1.
  messageEdge(
    # The method to use when ordering `Message`.
    orderBy: MessagesOrderBy = PRIMARY_KEY_ASC
  ): MessagesEdge

  # Reads a single `Conversation` that is related to this `Message`.
  conversationByConversationId: Conversation

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createNutrient` mutation.
input CreateNutrientInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Nutrient` to be created by this mutation.
  nutrient: NutrientInput!
}

# The output of our `createNutrient` mutation.
type CreateNutrientPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Nutrient` that was created by this mutation.
  nutrient: Nutrient

  # An edge for our `Nutrient`. May be used by Relay 1.
  nutrientEdge(
    # The method to use when ordering `Nutrient`.
    orderBy: NutrientsOrderBy = PRIMARY_KEY_ASC
  ): NutrientsEdge

  # Reads a single `UnitOfMeasure` that is related to this `Nutrient`.
  unitOfMeasureByUnitOfMeasureUsdaKey: UnitOfMeasure

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createPhysicalChange` mutation.
input CreatePhysicalChangeInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `PhysicalChange` to be created by this mutation.
  physicalChange: PhysicalChangeInput!
}

# The output of our `createPhysicalChange` mutation.
type CreatePhysicalChangePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `PhysicalChange` that was created by this mutation.
  physicalChange: PhysicalChange

  # An edge for our `PhysicalChange`. May be used by Relay 1.
  physicalChangeEdge(
    # The method to use when ordering `PhysicalChange`.
    orderBy: PhysicalChangesOrderBy = PRIMARY_KEY_ASC
  ): PhysicalChangesEdge

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createPlace` mutation.
input CreatePlaceInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Place` to be created by this mutation.
  place: PlaceInput!
}

# The output of our `createPlace` mutation.
type CreatePlacePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Place` that was created by this mutation.
  place: Place

  # An edge for our `Place`. May be used by Relay 1.
  placeEdge(
    # The method to use when ordering `Place`.
    orderBy: PlacesOrderBy = PRIMARY_KEY_ASC
  ): PlacesEdge

  # Reads a single `User` that is related to this `Place`.
  userByOwnerId: User

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createPreset` mutation.
input CreatePresetInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Preset` to be created by this mutation.
  preset: PresetInput!
}

# The output of our `createPreset` mutation.
type CreatePresetPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Preset` that was created by this mutation.
  preset: Preset

  # An edge for our `Preset`. May be used by Relay 1.
  presetEdge(
    # The method to use when ordering `Preset`.
    orderBy: PresetsOrderBy = PRIMARY_KEY_ASC
  ): PresetsEdge

  # Reads a single `User` that is related to this `Preset`.
  userByUserId: User

  # Reads a single `Conversation` that is related to this `Preset`.
  conversationByConversationId: Conversation

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createPresetSelection` mutation.
input CreatePresetSelectionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `PresetSelection` to be created by this mutation.
  presetSelection: PresetSelectionInput!
}

# The output of our `createPresetSelection` mutation.
type CreatePresetSelectionPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `PresetSelection` that was created by this mutation.
  presetSelection: PresetSelection

  # An edge for our `PresetSelection`. May be used by Relay 1.
  presetSelectionEdge(
    # The method to use when ordering `PresetSelection`.
    orderBy: PresetSelectionsOrderBy = PRIMARY_KEY_ASC
  ): PresetSelectionsEdge

  # Reads a single `Preset` that is related to this `PresetSelection`.
  presetByPresetId: Preset

  # Reads a single `FoodSelection` that is related to this `PresetSelection`.
  foodSelectionBySelectionId: FoodSelection

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createUnitOfMeasure` mutation.
input CreateUnitOfMeasureInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `UnitOfMeasure` to be created by this mutation.
  unitOfMeasure: UnitOfMeasureInput!
}

# The output of our `createUnitOfMeasure` mutation.
type CreateUnitOfMeasurePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `UnitOfMeasure` that was created by this mutation.
  unitOfMeasure: UnitOfMeasure

  # An edge for our `UnitOfMeasure`. May be used by Relay 1.
  unitOfMeasureEdge(
    # The method to use when ordering `UnitOfMeasure`.
    orderBy: UnitOfMeasuresOrderBy = PRIMARY_KEY_ASC
  ): UnitOfMeasuresEdge

  # Reads a single `UnitOfMeasure` that is related to this `UnitOfMeasure`.
  unitOfMeasureByShortNameRef: UnitOfMeasure

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createUser` mutation.
input CreateUserInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `User` to be created by this mutation.
  user: UserInput!
}

# The output of our `createUser` mutation.
type CreateUserPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `User` that was created by this mutation.
  user: User

  # An edge for our `User`. May be used by Relay 1.
  userEdge(
    # The method to use when ordering `User`.
    orderBy: UsersOrderBy = PRIMARY_KEY_ASC
  ): UsersEdge

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# A location in a connection that can be used for resuming pagination.
scalar Cursor

# The day, does not include a time.
scalar Date

# A point in time as described by the [ISO
# 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
scalar Datetime

# All input for the `deleteBrandByEmail` mutation.
input DeleteBrandByEmailInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The brand’s primary email address.
  email: String!
}

# All input for the `deleteBrandByName` mutation.
input DeleteBrandByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The brand’s human-readable name.
  name: String!
}

# All input for the `deleteBrandByPhone` mutation.
input DeleteBrandByPhoneInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The brand’s phone number.
  phone: String!
}

# All input for the `deleteBrandByRowId` mutation.
input DeleteBrandByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The unique identifier for the brand.
  rowId: Uuid!
}

# All input for the `deleteBrand` mutation.
input DeleteBrandInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Brand` to be deleted.
  id: ID!
}

# The output of our `deleteBrand` mutation.
type DeleteBrandPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  brand: Brand
  deletedBrandId: ID

  # Reads a single `User` that is related to this `Brand`.
  userByOwnerId: User

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteChemicalChangeByName` mutation.
input DeleteChemicalChangeByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The human-readable name of the chemical change, e.x. cooked, baked, fermented, dehydrated.
  name: String!
}

# All input for the `deleteChemicalChange` mutation.
input DeleteChemicalChangeInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `ChemicalChange` to be deleted.
  id: ID!
}

# The output of our `deleteChemicalChange` mutation.
type DeleteChemicalChangePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  chemicalChange: ChemicalChange
  deletedChemicalChangeId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteConversationByRowId` mutation.
input DeleteConversationByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The unique identifier for the conversation which is provided by the agent.
  rowId: Uuid!
}

# All input for the `deleteConversation` mutation.
input DeleteConversationInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Conversation` to be deleted.
  id: ID!
}

# The output of our `deleteConversation` mutation.
type DeleteConversationPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  conversation: Conversation
  deletedConversationId: ID

  # Reads a single `User` that is related to this `Conversation`.
  userByUserId: User

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteFoodByRowId` mutation.
input DeleteFoodByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # 5-digit or 8-digit Nutrient Databank number that uniquely identifies a food item.
  rowId: Float!
}

# All input for the `deleteFoodGroupByRowId` mutation.
input DeleteFoodGroupByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # 4-digit code identifying a food group. Only the first 2 digits are currently assigned.
  rowId: Float!
}

# All input for the `deleteFoodGroup` mutation.
input DeleteFoodGroupInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `FoodGroup` to be deleted.
  id: ID!
}

# The output of our `deleteFoodGroup` mutation.
type DeleteFoodGroupPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  foodGroup: FoodGroup
  deletedFoodGroupId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteFood` mutation.
input DeleteFoodInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Food` to be deleted.
  id: ID!
}

# All input for the `deleteFoodNutrientByFoodIdAndNutrientId` mutation.
input DeleteFoodNutrientByFoodIdAndNutrientIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # 5-digit or 8-digit Nutrient Databank number that uniquely identifies a food item.
  foodId: Float!

  # Unique 3-digit identifier code for a nutrient.
  nutrientId: Float!
}

# All input for the `deleteFoodNutrient` mutation.
input DeleteFoodNutrientInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `FoodNutrient` to be deleted.
  id: ID!
}

# The output of our `deleteFoodNutrient` mutation.
type DeleteFoodNutrientPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  foodNutrient: FoodNutrient
  deletedFoodNutrientId: ID

  # Reads a single `Food` that is related to this `FoodNutrient`.
  foodByFoodId: Food

  # Reads a single `Nutrient` that is related to this `FoodNutrient`.
  nutrientByNutrientId: Nutrient

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# The output of our `deleteFood` mutation.
type DeleteFoodPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  food: Food
  deletedFoodId: ID

  # Reads a single `FoodGroup` that is related to this `Food`.
  foodGroupByFoodGroupId: FoodGroup

  # Reads a single `Brand` that is related to this `Food`.
  brandByBrandName: Brand

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteFoodSelectionByRowId` mutation.
input DeleteFoodSelectionByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The food selection’s unique identifier.
  rowId: Uuid!
}

# All input for the `deleteFoodSelection` mutation.
input DeleteFoodSelectionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `FoodSelection` to be deleted.
  id: ID!
}

# The output of our `deleteFoodSelection` mutation.
type DeleteFoodSelectionPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  foodSelection: FoodSelection
  deletedFoodSelectionId: ID

  # Reads a single `User` that is related to this `FoodSelection`.
  userByUserId: User

  # Reads a single `Conversation` that is related to this `FoodSelection`.
  conversationByConversationId: Conversation

  # Reads a single `Preset` that is related to this `FoodSelection`.
  presetByInheritsFromId: Preset

  # Reads a single `Place` that is related to this `FoodSelection`.
  placeByPlaceId: Place

  # Reads a single `Food` that is related to this `FoodSelection`.
  foodByFoodId: Food

  # Reads a single `Brand` that is related to this `FoodSelection`.
  brandByBrandId: Brand

  # Reads a single `ChemicalChange` that is related to this `FoodSelection`.
  chemicalChangeByChemicalChangeName: ChemicalChange

  # Reads a single `PhysicalChange` that is related to this `FoodSelection`.
  physicalChangeByPhysicalChangeName: PhysicalChange

  # Reads a single `UnitOfMeasure` that is related to this `FoodSelection`.
  unitOfMeasureByUnitOfMeasureId: UnitOfMeasure

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteMassConversionByFoodIdAndUnitOfMeasureIdAndPhysicalChangeName` mutation.
input DeleteMassConversionByFoodIdAndUnitOfMeasureIdAndPhysicalChangeNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The unique identifier for the food item.
  foodId: Float!

  # The unique identifier for the initial unit of measure which is a volume or count unit, e.x. liter, drumstick, piece, box.
  unitOfMeasureId: Int!

  # The unique name for the physical form or process the food is in.
  physicalChangeName: String!
}

# All input for the `deleteMassConversionByRowId` mutation.
input DeleteMassConversionByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  rowId: Int!
}

# All input for the `deleteMassConversion` mutation.
input DeleteMassConversionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `MassConversion` to be deleted.
  id: ID!
}

# The output of our `deleteMassConversion` mutation.
type DeleteMassConversionPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  massConversion: MassConversion
  deletedMassConversionId: ID

  # Reads a single `Food` that is related to this `MassConversion`.
  foodByFoodId: Food

  # Reads a single `UnitOfMeasure` that is related to this `MassConversion`.
  unitOfMeasureByUnitOfMeasureId: UnitOfMeasure

  # Reads a single `PhysicalChange` that is related to this `MassConversion`.
  physicalChangeByPhysicalChangeName: PhysicalChange

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteMessageByRowId` mutation.
input DeleteMessageByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The unique identifier for the message which is provided by the agent.
  rowId: Uuid!
}

# All input for the `deleteMessage` mutation.
input DeleteMessageInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Message` to be deleted.
  id: ID!
}

# The output of our `deleteMessage` mutation.
type DeleteMessagePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  message: Message
  deletedMessageId: ID

  # Reads a single `Conversation` that is related to this `Message`.
  conversationByConversationId: Conversation

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteNutrientByRowId` mutation.
input DeleteNutrientByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # Unique 3-digit identifier code for a nutrient.
  rowId: Float!
}

# All input for the `deleteNutrient` mutation.
input DeleteNutrientInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Nutrient` to be deleted.
  id: ID!
}

# The output of our `deleteNutrient` mutation.
type DeleteNutrientPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  nutrient: Nutrient
  deletedNutrientId: ID

  # Reads a single `UnitOfMeasure` that is related to this `Nutrient`.
  unitOfMeasureByUnitOfMeasureUsdaKey: UnitOfMeasure

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deletePhysicalChangeByName` mutation.
input DeletePhysicalChangeByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The human-readable name of the physical change, e.x. diced, farmers cut, blended, liquid.
  name: String!
}

# All input for the `deletePhysicalChange` mutation.
input DeletePhysicalChangeInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `PhysicalChange` to be deleted.
  id: ID!
}

# The output of our `deletePhysicalChange` mutation.
type DeletePhysicalChangePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  physicalChange: PhysicalChange
  deletedPhysicalChangeId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deletePlaceByName` mutation.
input DeletePlaceByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The place’s human-readable name.
  name: String!
}

# All input for the `deletePlaceByRowId` mutation.
input DeletePlaceByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The unique identifier for the place.
  rowId: Uuid!
}

# All input for the `deletePlace` mutation.
input DeletePlaceInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Place` to be deleted.
  id: ID!
}

# The output of our `deletePlace` mutation.
type DeletePlacePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  place: Place
  deletedPlaceId: ID

  # Reads a single `User` that is related to this `Place`.
  userByOwnerId: User

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deletePresetByRowId` mutation.
input DeletePresetByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The unique identifier for the preset.
  rowId: Uuid!
}

# All input for the `deletePresetByUserIdAndName` mutation.
input DeletePresetByUserIdAndNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The unique identifier for the person.
  userId: Uuid!

  # A name for the preset which is unique per user id so it can be conveniently referenced.
  name: String!
}

# All input for the `deletePreset` mutation.
input DeletePresetInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Preset` to be deleted.
  id: ID!
}

# The output of our `deletePreset` mutation.
type DeletePresetPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  preset: Preset
  deletedPresetId: ID

  # Reads a single `User` that is related to this `Preset`.
  userByUserId: User

  # Reads a single `Conversation` that is related to this `Preset`.
  conversationByConversationId: Conversation

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deletePresetSelectionByPresetIdAndSelectionId` mutation.
input DeletePresetSelectionByPresetIdAndSelectionIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The unique identifier for the preset.
  presetId: Uuid!

  # The unique identifier for the food selection.
  selectionId: Uuid!
}

# All input for the `deletePresetSelection` mutation.
input DeletePresetSelectionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `PresetSelection` to be deleted.
  id: ID!
}

# The output of our `deletePresetSelection` mutation.
type DeletePresetSelectionPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  presetSelection: PresetSelection
  deletedPresetSelectionId: ID

  # Reads a single `Preset` that is related to this `PresetSelection`.
  presetByPresetId: Preset

  # Reads a single `FoodSelection` that is related to this `PresetSelection`.
  foodSelectionBySelectionId: FoodSelection

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteUnitOfMeasureByFullName` mutation.
input DeleteUnitOfMeasureByFullNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The full name of the unit of measure, e.x. cup, milliliter, gram, whole.
  fullName: String!
}

# All input for the `deleteUnitOfMeasureByRowId` mutation.
input DeleteUnitOfMeasureByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The unique identifier for the unit of measure.
  rowId: Int!
}

# All input for the `deleteUnitOfMeasureByShortName` mutation.
input DeleteUnitOfMeasureByShortNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The abbreviated or shortened name for the unit of measure, e.x. c, g, mg.
  shortName: String!
}

# All input for the `deleteUnitOfMeasureByUsdaKey` mutation.
input DeleteUnitOfMeasureByUsdaKeyInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The original unique string from the USDA NDB for a unit of measure. Typos and
  # inconsistent plurals and abbreviations led to duplicated entries of the same
  # unit (e.x. cup, cups, and c). This column preserves those unique references.
  usdaKey: String!
}

# All input for the `deleteUnitOfMeasure` mutation.
input DeleteUnitOfMeasureInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `UnitOfMeasure` to be deleted.
  id: ID!
}

# The output of our `deleteUnitOfMeasure` mutation.
type DeleteUnitOfMeasurePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  unitOfMeasure: UnitOfMeasure
  deletedUnitOfMeasureId: ID

  # Reads a single `UnitOfMeasure` that is related to this `UnitOfMeasure`.
  unitOfMeasureByShortNameRef: UnitOfMeasure

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteUserByPhone` mutation.
input DeleteUserByPhoneInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # A phone number. Phone numbers must be unique across all users and must match the E.164 numbering spec.
  phone: String!
}

# All input for the `deleteUserByRowId` mutation.
input DeleteUserByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The user’s unique identifier.
  rowId: Uuid!
}

# All input for the `deleteUser` mutation.
input DeleteUserInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `User` to be deleted.
  id: ID!
}

# The output of our `deleteUser` mutation.
type DeleteUserPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  user: User
  deletedUserId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# Contains all food items from the USDA Nutrient Databank Standard Reference 28
type Food implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # 5-digit or 8-digit Nutrient Databank number that uniquely identifies a food item.
  rowId: Float!

  # 4-digit code indicating food group to which a food item belongs.
  foodGroupId: Float

  # Indicates the company that manufactured the product, when appropriate.
  brandName: String

  # 200-character description of food item.
  longDescription: String!

  # 60-character abbreviated description of food item. Generated from the
  # 200-character description using abbreviations in Appendix A. If short
  # description is longer than 60 characters, additional abbreviations are made.
  shortDescription: String!

  # Description of inedible parts of a food item (refuse), such as seeds or bone.
  refuseDescription: String

  # Percentage of refuse.
  refuse: Float

  # Factor for calculating calories from protein.
  proteinFactor: Float

  # Factor for calculating calories from fat.
  fatFactor: Float

  # Factor for calculating calories from carbohydrate.
  carbFactor: Float

  # Water (g/100g)
  water: Float

  # Food energy (kcal/100g)
  calories: Float

  # Protein (g/100g)
  protein: Float

  # Total lipid (fat) (g/100g)
  fat: Float

  # Ash (g/100g)
  ash: Float

  # Carbohydrate, by difference (g/100g)
  carbs: Float

  # Total dietary fiber (g/100g)
  fiber: Float

  # Total sugars (g/100g)
  sugar: Float

  # Calcium (mg/100g)
  calcium: Float

  # Iron (mg/100g)
  iron: Float

  # Magnesium (mg/100g)
  magnesium: Float

  # Phosphorus (mg/100g)
  phosphorus: Float

  # Potassium (mg/100g)
  potassium: Float

  # Sodium (mg/100g)
  sodium: Float

  # Zinc (mg/100g)
  zinc: Float

  # Copper (mg/100g)
  copper: Float

  # Manganese (mg/100g)
  manganese: Float

  # Selenium (μg/100g)
  selenium: Float

  # Vitamin C (mg/100g)
  vitaminC: Float

  # Thiamin (mg/100g)
  thiamin: Float

  # Riboflavin (mg/100g)
  riboflavin: Float

  # Niacin (mg/100g)
  niacin: Float

  # Pantothenic acid (mg/100g)
  pantoAcid: Float

  # Vitamin B6 (mg/100g)
  vitaminB6: Float

  # Folate, total (μg/100g)
  folate: Float

  # Folic acid (μg/100g)
  folicAcid: Float

  # Food folate (μg/100g)
  foodFolate: Float

  # Folate (μg dietary folate equivalents/100g)
  folateDfe: Float

  # Choline, total (mg/100g)
  choline: Float

  # Vitamin B12 (μg/100g)
  vitaminB12: Float

  # Vitamin A (IU/100g)
  vitaminAIu: Float

  # Vitamin A (μg retinol activity equivalents/100g)
  vitaminARae: Float

  # Retinol (μg/100g)
  retinol: Float

  # Alpha-carotene (μg/100g)
  alphaCarot: Float

  # Beta-carotene (μg/100g)
  betaCarot: Float

  # Beta-cryptoxanthin (μg/100g)
  betaCrypt: Float

  # Lycopene (μg/100g)
  lycopene: Float

  # Lutein+zeazanthin (μg/100g)
  lutZea: Float

  # Vitamin E (alpha-tocopherol) (mg/100g)
  vitaminE: Float

  # Vitamin D (μg/100g)
  vitaminDMcg: Float

  # Vitamin D (IU/100g)
  vitaminDIu: Float

  # Vitamin K (phylloquinone) (μg/100g)
  vitaminK: Float

  # Saturated fatty acid (g/100g)
  fatSat: Float

  # Monounsaturated fatty acids (g/100g)
  fatMono: Float

  # Polyunsaturated fatty acids (g/100g)
  fatPoly: Float

  # Cholesterol (mg/100g)
  cholesterol: Float

  # The time this object was created.
  createdAt: Datetime

  # The time this object was last updated.
  updatedAt: Datetime

  # Reads a single `FoodGroup` that is related to this `Food`.
  foodGroupByFoodGroupId: FoodGroup

  # Reads a single `Brand` that is related to this `Food`.
  brandByBrandName: Brand

  # Reads and enables pagination through a set of `FoodSelection`.
  foodSelectionsByFoodId(
    # The method to use when ordering `FoodSelection`.
    orderBy: FoodSelectionsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: FoodSelectionCondition
  ): FoodSelectionsConnection

  # Reads and enables pagination through a set of `MassConversion`.
  massConversionsByFoodId(
    # The method to use when ordering `MassConversion`.
    orderBy: MassConversionsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: MassConversionCondition
  ): MassConversionsConnection

  # Reads and enables pagination through a set of `FoodNutrient`.
  foodNutrientsByFoodId(
    # The method to use when ordering `FoodNutrient`.
    orderBy: FoodNutrientsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: FoodNutrientCondition
  ): FoodNutrientsConnection
}

# A condition to be used against `Food` object types. All fields are tested for equality and combined with a logical ‘and.’
input FoodCondition {
  # Checks for equality with the object’s `rowId` field.
  rowId: Float

  # Checks for equality with the object’s `foodGroupId` field.
  foodGroupId: Float

  # Checks for equality with the object’s `brandName` field.
  brandName: String

  # Checks for equality with the object’s `longDescription` field.
  longDescription: String

  # Checks for equality with the object’s `shortDescription` field.
  shortDescription: String

  # Checks for equality with the object’s `refuseDescription` field.
  refuseDescription: String

  # Checks for equality with the object’s `refuse` field.
  refuse: Float

  # Checks for equality with the object’s `proteinFactor` field.
  proteinFactor: Float

  # Checks for equality with the object’s `fatFactor` field.
  fatFactor: Float

  # Checks for equality with the object’s `carbFactor` field.
  carbFactor: Float

  # Checks for equality with the object’s `water` field.
  water: Float

  # Checks for equality with the object’s `calories` field.
  calories: Float

  # Checks for equality with the object’s `protein` field.
  protein: Float

  # Checks for equality with the object’s `fat` field.
  fat: Float

  # Checks for equality with the object’s `ash` field.
  ash: Float

  # Checks for equality with the object’s `carbs` field.
  carbs: Float

  # Checks for equality with the object’s `fiber` field.
  fiber: Float

  # Checks for equality with the object’s `sugar` field.
  sugar: Float

  # Checks for equality with the object’s `calcium` field.
  calcium: Float

  # Checks for equality with the object’s `iron` field.
  iron: Float

  # Checks for equality with the object’s `magnesium` field.
  magnesium: Float

  # Checks for equality with the object’s `phosphorus` field.
  phosphorus: Float

  # Checks for equality with the object’s `potassium` field.
  potassium: Float

  # Checks for equality with the object’s `sodium` field.
  sodium: Float

  # Checks for equality with the object’s `zinc` field.
  zinc: Float

  # Checks for equality with the object’s `copper` field.
  copper: Float

  # Checks for equality with the object’s `manganese` field.
  manganese: Float

  # Checks for equality with the object’s `selenium` field.
  selenium: Float

  # Checks for equality with the object’s `vitaminC` field.
  vitaminC: Float

  # Checks for equality with the object’s `thiamin` field.
  thiamin: Float

  # Checks for equality with the object’s `riboflavin` field.
  riboflavin: Float

  # Checks for equality with the object’s `niacin` field.
  niacin: Float

  # Checks for equality with the object’s `pantoAcid` field.
  pantoAcid: Float

  # Checks for equality with the object’s `vitaminB6` field.
  vitaminB6: Float

  # Checks for equality with the object’s `folate` field.
  folate: Float

  # Checks for equality with the object’s `folicAcid` field.
  folicAcid: Float

  # Checks for equality with the object’s `foodFolate` field.
  foodFolate: Float

  # Checks for equality with the object’s `folateDfe` field.
  folateDfe: Float

  # Checks for equality with the object’s `choline` field.
  choline: Float

  # Checks for equality with the object’s `vitaminB12` field.
  vitaminB12: Float

  # Checks for equality with the object’s `vitaminAIu` field.
  vitaminAIu: Float

  # Checks for equality with the object’s `vitaminARae` field.
  vitaminARae: Float

  # Checks for equality with the object’s `retinol` field.
  retinol: Float

  # Checks for equality with the object’s `alphaCarot` field.
  alphaCarot: Float

  # Checks for equality with the object’s `betaCarot` field.
  betaCarot: Float

  # Checks for equality with the object’s `betaCrypt` field.
  betaCrypt: Float

  # Checks for equality with the object’s `lycopene` field.
  lycopene: Float

  # Checks for equality with the object’s `lutZea` field.
  lutZea: Float

  # Checks for equality with the object’s `vitaminE` field.
  vitaminE: Float

  # Checks for equality with the object’s `vitaminDMcg` field.
  vitaminDMcg: Float

  # Checks for equality with the object’s `vitaminDIu` field.
  vitaminDIu: Float

  # Checks for equality with the object’s `vitaminK` field.
  vitaminK: Float

  # Checks for equality with the object’s `fatSat` field.
  fatSat: Float

  # Checks for equality with the object’s `fatMono` field.
  fatMono: Float

  # Checks for equality with the object’s `fatPoly` field.
  fatPoly: Float

  # Checks for equality with the object’s `cholesterol` field.
  cholesterol: Float

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# A support table to the food table that contains a list of food groups used in SR28 and their descriptions.
type FoodGroup implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # 4-digit code identifying a food group. Only the first 2 digits are currently assigned.
  rowId: Float!

  # The name of the food group.
  name: String!

  # Reads and enables pagination through a set of `Food`.
  foodsByFoodGroupId(
    # The method to use when ordering `Food`.
    orderBy: FoodsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: FoodCondition
  ): FoodsConnection
}

# A condition to be used against `FoodGroup` object types. All fields are tested
# for equality and combined with a logical ‘and.’
input FoodGroupCondition {
  # Checks for equality with the object’s `rowId` field.
  rowId: Float

  # Checks for equality with the object’s `name` field.
  name: String
}

# A support table to the food table that contains a list of food groups used in SR28 and their descriptions.
input FoodGroupInput {
  # 4-digit code identifying a food group. Only the first 2 digits are currently assigned.
  rowId: Float!

  # The name of the food group.
  name: String!
}

# Represents an update to a `FoodGroup`. Fields that are set will be updated.
input FoodGroupPatch {
  # 4-digit code identifying a food group. Only the first 2 digits are currently assigned.
  rowId: Float

  # The name of the food group.
  name: String
}

# A connection to a list of `FoodGroup` values.
type FoodGroupsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `FoodGroup` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `FoodGroup` and cursor to aid in pagination.
  edges: [FoodGroupsEdge]

  # A list of `FoodGroup` objects.
  nodes: [FoodGroup!]
}

# A `FoodGroup` edge in the connection.
type FoodGroupsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `FoodGroup` at the end of the edge.
  node: FoodGroup!
}

# Methods to use when ordering `FoodGroup`.
enum FoodGroupsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
}

# Contains all food items from the USDA Nutrient Databank Standard Reference 28
input FoodInput {
  # 5-digit or 8-digit Nutrient Databank number that uniquely identifies a food item.
  rowId: Float!

  # 4-digit code indicating food group to which a food item belongs.
  foodGroupId: Float

  # Indicates the company that manufactured the product, when appropriate.
  brandName: String

  # 200-character description of food item.
  longDescription: String!

  # 60-character abbreviated description of food item. Generated from the
  # 200-character description using abbreviations in Appendix A. If short
  # description is longer than 60 characters, additional abbreviations are made.
  shortDescription: String!

  # Description of inedible parts of a food item (refuse), such as seeds or bone.
  refuseDescription: String

  # Percentage of refuse.
  refuse: Float

  # Factor for calculating calories from protein.
  proteinFactor: Float

  # Factor for calculating calories from fat.
  fatFactor: Float

  # Factor for calculating calories from carbohydrate.
  carbFactor: Float

  # Water (g/100g)
  water: Float

  # Food energy (kcal/100g)
  calories: Float

  # Protein (g/100g)
  protein: Float

  # Total lipid (fat) (g/100g)
  fat: Float

  # Ash (g/100g)
  ash: Float

  # Carbohydrate, by difference (g/100g)
  carbs: Float

  # Total dietary fiber (g/100g)
  fiber: Float

  # Total sugars (g/100g)
  sugar: Float

  # Calcium (mg/100g)
  calcium: Float

  # Iron (mg/100g)
  iron: Float

  # Magnesium (mg/100g)
  magnesium: Float

  # Phosphorus (mg/100g)
  phosphorus: Float

  # Potassium (mg/100g)
  potassium: Float

  # Sodium (mg/100g)
  sodium: Float

  # Zinc (mg/100g)
  zinc: Float

  # Copper (mg/100g)
  copper: Float

  # Manganese (mg/100g)
  manganese: Float

  # Selenium (μg/100g)
  selenium: Float

  # Vitamin C (mg/100g)
  vitaminC: Float

  # Thiamin (mg/100g)
  thiamin: Float

  # Riboflavin (mg/100g)
  riboflavin: Float

  # Niacin (mg/100g)
  niacin: Float

  # Pantothenic acid (mg/100g)
  pantoAcid: Float

  # Vitamin B6 (mg/100g)
  vitaminB6: Float

  # Folate, total (μg/100g)
  folate: Float

  # Folic acid (μg/100g)
  folicAcid: Float

  # Food folate (μg/100g)
  foodFolate: Float

  # Folate (μg dietary folate equivalents/100g)
  folateDfe: Float

  # Choline, total (mg/100g)
  choline: Float

  # Vitamin B12 (μg/100g)
  vitaminB12: Float

  # Vitamin A (IU/100g)
  vitaminAIu: Float

  # Vitamin A (μg retinol activity equivalents/100g)
  vitaminARae: Float

  # Retinol (μg/100g)
  retinol: Float

  # Alpha-carotene (μg/100g)
  alphaCarot: Float

  # Beta-carotene (μg/100g)
  betaCarot: Float

  # Beta-cryptoxanthin (μg/100g)
  betaCrypt: Float

  # Lycopene (μg/100g)
  lycopene: Float

  # Lutein+zeazanthin (μg/100g)
  lutZea: Float

  # Vitamin E (alpha-tocopherol) (mg/100g)
  vitaminE: Float

  # Vitamin D (μg/100g)
  vitaminDMcg: Float

  # Vitamin D (IU/100g)
  vitaminDIu: Float

  # Vitamin K (phylloquinone) (μg/100g)
  vitaminK: Float

  # Saturated fatty acid (g/100g)
  fatSat: Float

  # Monounsaturated fatty acids (g/100g)
  fatMono: Float

  # Polyunsaturated fatty acids (g/100g)
  fatPoly: Float

  # Cholesterol (mg/100g)
  cholesterol: Float

  # The time this object was created.
  createdAt: Datetime

  # The time this object was last updated.
  updatedAt: Datetime
}

# Contains the nutrient values and information about the values, including expanded statistical information.
type FoodNutrient implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # 5-digit or 8-digit Nutrient Databank number that uniquely identifies a food item.
  foodId: Float!

  # Unique 3-digit identifier code for a nutrient.
  nutrientId: Float!

  # Amount in 100 grams, edible portion.
  nutrientValue: Float!

  # Standard error of the mean. Null if cannot be calculated. The standard error
  # is also not given if the number of data points is less than three.
  standardError: Float

  # Minimum value.
  min: Float

  # Maximum value.
  max: Float

  # Lower 95% error bound.
  lowerErrorBound: Float

  # Upper 95% error bound.
  upperErrorBound: Float

  # Reads a single `Food` that is related to this `FoodNutrient`.
  foodByFoodId: Food

  # Reads a single `Nutrient` that is related to this `FoodNutrient`.
  nutrientByNutrientId: Nutrient
}

# A condition to be used against `FoodNutrient` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input FoodNutrientCondition {
  # Checks for equality with the object’s `foodId` field.
  foodId: Float

  # Checks for equality with the object’s `nutrientId` field.
  nutrientId: Float

  # Checks for equality with the object’s `nutrientValue` field.
  nutrientValue: Float

  # Checks for equality with the object’s `standardError` field.
  standardError: Float

  # Checks for equality with the object’s `min` field.
  min: Float

  # Checks for equality with the object’s `max` field.
  max: Float

  # Checks for equality with the object’s `lowerErrorBound` field.
  lowerErrorBound: Float

  # Checks for equality with the object’s `upperErrorBound` field.
  upperErrorBound: Float
}

# Contains the nutrient values and information about the values, including expanded statistical information.
input FoodNutrientInput {
  # 5-digit or 8-digit Nutrient Databank number that uniquely identifies a food item.
  foodId: Float!

  # Unique 3-digit identifier code for a nutrient.
  nutrientId: Float!

  # Amount in 100 grams, edible portion.
  nutrientValue: Float!

  # Standard error of the mean. Null if cannot be calculated. The standard error
  # is also not given if the number of data points is less than three.
  standardError: Float

  # Minimum value.
  min: Float

  # Maximum value.
  max: Float

  # Lower 95% error bound.
  lowerErrorBound: Float

  # Upper 95% error bound.
  upperErrorBound: Float
}

# Represents an update to a `FoodNutrient`. Fields that are set will be updated.
input FoodNutrientPatch {
  # 5-digit or 8-digit Nutrient Databank number that uniquely identifies a food item.
  foodId: Float

  # Unique 3-digit identifier code for a nutrient.
  nutrientId: Float

  # Amount in 100 grams, edible portion.
  nutrientValue: Float

  # Standard error of the mean. Null if cannot be calculated. The standard error
  # is also not given if the number of data points is less than three.
  standardError: Float

  # Minimum value.
  min: Float

  # Maximum value.
  max: Float

  # Lower 95% error bound.
  lowerErrorBound: Float

  # Upper 95% error bound.
  upperErrorBound: Float
}

# A connection to a list of `FoodNutrient` values.
type FoodNutrientsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `FoodNutrient` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `FoodNutrient` and cursor to aid in pagination.
  edges: [FoodNutrientsEdge]

  # A list of `FoodNutrient` objects.
  nodes: [FoodNutrient!]
}

# A `FoodNutrient` edge in the connection.
type FoodNutrientsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `FoodNutrient` at the end of the edge.
  node: FoodNutrient!
}

# Methods to use when ordering `FoodNutrient`.
enum FoodNutrientsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  FOOD_ID_ASC
  FOOD_ID_DESC
  NUTRIENT_ID_ASC
  NUTRIENT_ID_DESC
  NUTRIENT_VALUE_ASC
  NUTRIENT_VALUE_DESC
  STANDARD_ERROR_ASC
  STANDARD_ERROR_DESC
  MIN_ASC
  MIN_DESC
  MAX_ASC
  MAX_DESC
  LOWER_ERROR_BOUND_ASC
  LOWER_ERROR_BOUND_DESC
  UPPER_ERROR_BOUND_ASC
  UPPER_ERROR_BOUND_DESC
}

# Represents an update to a `Food`. Fields that are set will be updated.
input FoodPatch {
  # 5-digit or 8-digit Nutrient Databank number that uniquely identifies a food item.
  rowId: Float

  # 4-digit code indicating food group to which a food item belongs.
  foodGroupId: Float

  # Indicates the company that manufactured the product, when appropriate.
  brandName: String

  # 200-character description of food item.
  longDescription: String

  # 60-character abbreviated description of food item. Generated from the
  # 200-character description using abbreviations in Appendix A. If short
  # description is longer than 60 characters, additional abbreviations are made.
  shortDescription: String

  # Description of inedible parts of a food item (refuse), such as seeds or bone.
  refuseDescription: String

  # Percentage of refuse.
  refuse: Float

  # Factor for calculating calories from protein.
  proteinFactor: Float

  # Factor for calculating calories from fat.
  fatFactor: Float

  # Factor for calculating calories from carbohydrate.
  carbFactor: Float

  # Water (g/100g)
  water: Float

  # Food energy (kcal/100g)
  calories: Float

  # Protein (g/100g)
  protein: Float

  # Total lipid (fat) (g/100g)
  fat: Float

  # Ash (g/100g)
  ash: Float

  # Carbohydrate, by difference (g/100g)
  carbs: Float

  # Total dietary fiber (g/100g)
  fiber: Float

  # Total sugars (g/100g)
  sugar: Float

  # Calcium (mg/100g)
  calcium: Float

  # Iron (mg/100g)
  iron: Float

  # Magnesium (mg/100g)
  magnesium: Float

  # Phosphorus (mg/100g)
  phosphorus: Float

  # Potassium (mg/100g)
  potassium: Float

  # Sodium (mg/100g)
  sodium: Float

  # Zinc (mg/100g)
  zinc: Float

  # Copper (mg/100g)
  copper: Float

  # Manganese (mg/100g)
  manganese: Float

  # Selenium (μg/100g)
  selenium: Float

  # Vitamin C (mg/100g)
  vitaminC: Float

  # Thiamin (mg/100g)
  thiamin: Float

  # Riboflavin (mg/100g)
  riboflavin: Float

  # Niacin (mg/100g)
  niacin: Float

  # Pantothenic acid (mg/100g)
  pantoAcid: Float

  # Vitamin B6 (mg/100g)
  vitaminB6: Float

  # Folate, total (μg/100g)
  folate: Float

  # Folic acid (μg/100g)
  folicAcid: Float

  # Food folate (μg/100g)
  foodFolate: Float

  # Folate (μg dietary folate equivalents/100g)
  folateDfe: Float

  # Choline, total (mg/100g)
  choline: Float

  # Vitamin B12 (μg/100g)
  vitaminB12: Float

  # Vitamin A (IU/100g)
  vitaminAIu: Float

  # Vitamin A (μg retinol activity equivalents/100g)
  vitaminARae: Float

  # Retinol (μg/100g)
  retinol: Float

  # Alpha-carotene (μg/100g)
  alphaCarot: Float

  # Beta-carotene (μg/100g)
  betaCarot: Float

  # Beta-cryptoxanthin (μg/100g)
  betaCrypt: Float

  # Lycopene (μg/100g)
  lycopene: Float

  # Lutein+zeazanthin (μg/100g)
  lutZea: Float

  # Vitamin E (alpha-tocopherol) (mg/100g)
  vitaminE: Float

  # Vitamin D (μg/100g)
  vitaminDMcg: Float

  # Vitamin D (IU/100g)
  vitaminDIu: Float

  # Vitamin K (phylloquinone) (μg/100g)
  vitaminK: Float

  # Saturated fatty acid (g/100g)
  fatSat: Float

  # Monounsaturated fatty acids (g/100g)
  fatMono: Float

  # Polyunsaturated fatty acids (g/100g)
  fatPoly: Float

  # Cholesterol (mg/100g)
  cholesterol: Float

  # The time this object was created.
  createdAt: Datetime

  # The time this object was last updated.
  updatedAt: Datetime
}

# A connection to a list of `Food` values.
type FoodsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Food` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Food` and cursor to aid in pagination.
  edges: [FoodsEdge]

  # A list of `Food` objects.
  nodes: [Food!]
}

# A `Food` edge in the connection.
type FoodsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Food` at the end of the edge.
  node: Food!
}

# A food item entered into a person’s food journal, like an ingredient or dish.
type FoodSelection implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # The food selection’s unique identifier.
  rowId: Uuid!

  # The unique identifier for the person.
  userId: Uuid!

  # The unique identifier for the conversation.
  conversationId: Uuid!

  # The unique identifier for the preset that this selection was copied from.
  inheritsFromId: Uuid

  # The unique identifier of the place.
  placeId: Uuid

  # The description of the place.
  placeDescription: String

  # The unique identifier for the food.
  foodId: Float

  # The description of the food.
  foodDescription: String
  foodIdSource: InputSource
  category: FoodSelectionCategory

  # The unique identifier for the brand.
  brandId: Uuid

  # The description of the brand.
  brandDescription: String

  # The unique name for the chemical change, if mentioned.
  chemicalChangeName: String

  # The unique name for the physical change, if mentioned.
  physicalChangeName: String

  # The unique identifier for the unit of measure, if mentioned.
  unitOfMeasureId: Int

  # The numeric component for describing quantity of food: e.x. 1/4 in 1/4 cup, 200 in 200 grams.
  unitQuantity: Float

  # The price paid for the food selection.
  unitPrice: Float

  # The total mass of the food in grams.
  mass: Float
  massSource: InputSource

  # A number that represents the person’s attitude or feelings about the food selection.
  ratingValue: Float

  # The date the food selection occurred, local to the person.
  date: Date

  # The time the food selection occurred, local to the person.
  time: Time

  # The original text of the food selection.
  original: String

  # Flags this food selection as something that was mentioned as an omission.
  omission: Boolean

  # The time this object was created.
  createdAt: Datetime

  # The time this object was last updated.
  updatedAt: Datetime

  # Reads a single `User` that is related to this `FoodSelection`.
  userByUserId: User

  # Reads a single `Conversation` that is related to this `FoodSelection`.
  conversationByConversationId: Conversation

  # Reads a single `Preset` that is related to this `FoodSelection`.
  presetByInheritsFromId: Preset

  # Reads a single `Place` that is related to this `FoodSelection`.
  placeByPlaceId: Place

  # Reads a single `Food` that is related to this `FoodSelection`.
  foodByFoodId: Food

  # Reads a single `Brand` that is related to this `FoodSelection`.
  brandByBrandId: Brand

  # Reads a single `ChemicalChange` that is related to this `FoodSelection`.
  chemicalChangeByChemicalChangeName: ChemicalChange

  # Reads a single `PhysicalChange` that is related to this `FoodSelection`.
  physicalChangeByPhysicalChangeName: PhysicalChange

  # Reads a single `UnitOfMeasure` that is related to this `FoodSelection`.
  unitOfMeasureByUnitOfMeasureId: UnitOfMeasure

  # Reads and enables pagination through a set of `PresetSelection`.
  presetSelectionsBySelectionId(
    # The method to use when ordering `PresetSelection`.
    orderBy: PresetSelectionsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: PresetSelectionCondition
  ): PresetSelectionsConnection
}

# The category of a food selection: collection (buying or acquiring), preparation
# (cooking, preserving, or prepping), consumption (eating), observation (general
# fallback for making a note about food).
enum FoodSelectionCategory {
  COLLECTION
  PREPARATION
  CONSUMPTION
  OBSERVATION
}

# A condition to be used against `FoodSelection` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input FoodSelectionCondition {
  # Checks for equality with the object’s `rowId` field.
  rowId: Uuid

  # Checks for equality with the object’s `userId` field.
  userId: Uuid

  # Checks for equality with the object’s `conversationId` field.
  conversationId: Uuid

  # Checks for equality with the object’s `inheritsFromId` field.
  inheritsFromId: Uuid

  # Checks for equality with the object’s `placeId` field.
  placeId: Uuid

  # Checks for equality with the object’s `placeDescription` field.
  placeDescription: String

  # Checks for equality with the object’s `foodId` field.
  foodId: Float

  # Checks for equality with the object’s `foodDescription` field.
  foodDescription: String

  # Checks for equality with the object’s `foodIdSource` field.
  foodIdSource: InputSource

  # Checks for equality with the object’s `category` field.
  category: FoodSelectionCategory

  # Checks for equality with the object’s `brandId` field.
  brandId: Uuid

  # Checks for equality with the object’s `brandDescription` field.
  brandDescription: String

  # Checks for equality with the object’s `chemicalChangeName` field.
  chemicalChangeName: String

  # Checks for equality with the object’s `physicalChangeName` field.
  physicalChangeName: String

  # Checks for equality with the object’s `unitOfMeasureId` field.
  unitOfMeasureId: Int

  # Checks for equality with the object’s `unitQuantity` field.
  unitQuantity: Float

  # Checks for equality with the object’s `unitPrice` field.
  unitPrice: Float

  # Checks for equality with the object’s `mass` field.
  mass: Float

  # Checks for equality with the object’s `massSource` field.
  massSource: InputSource

  # Checks for equality with the object’s `ratingValue` field.
  ratingValue: Float

  # Checks for equality with the object’s `date` field.
  date: Date

  # Checks for equality with the object’s `time` field.
  time: Time

  # Checks for equality with the object’s `original` field.
  original: String

  # Checks for equality with the object’s `omission` field.
  omission: Boolean

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# A food item entered into a person’s food journal, like an ingredient or dish.
input FoodSelectionInput {
  # The food selection’s unique identifier.
  rowId: Uuid

  # The unique identifier for the person.
  userId: Uuid!

  # The unique identifier for the conversation.
  conversationId: Uuid!

  # The unique identifier for the preset that this selection was copied from.
  inheritsFromId: Uuid

  # The unique identifier of the place.
  placeId: Uuid

  # The description of the place.
  placeDescription: String

  # The unique identifier for the food.
  foodId: Float

  # The description of the food.
  foodDescription: String
  foodIdSource: InputSource
  category: FoodSelectionCategory

  # The unique identifier for the brand.
  brandId: Uuid

  # The description of the brand.
  brandDescription: String

  # The unique name for the chemical change, if mentioned.
  chemicalChangeName: String

  # The unique name for the physical change, if mentioned.
  physicalChangeName: String

  # The unique identifier for the unit of measure, if mentioned.
  unitOfMeasureId: Int

  # The numeric component for describing quantity of food: e.x. 1/4 in 1/4 cup, 200 in 200 grams.
  unitQuantity: Float

  # The price paid for the food selection.
  unitPrice: Float

  # The total mass of the food in grams.
  mass: Float
  massSource: InputSource

  # A number that represents the person’s attitude or feelings about the food selection.
  ratingValue: Float

  # The date the food selection occurred, local to the person.
  date: Date

  # The time the food selection occurred, local to the person.
  time: Time

  # The original text of the food selection.
  original: String

  # Flags this food selection as something that was mentioned as an omission.
  omission: Boolean

  # The time this object was created.
  createdAt: Datetime

  # The time this object was last updated.
  updatedAt: Datetime
}

# Represents an update to a `FoodSelection`. Fields that are set will be updated.
input FoodSelectionPatch {
  # The food selection’s unique identifier.
  rowId: Uuid

  # The unique identifier for the person.
  userId: Uuid

  # The unique identifier for the conversation.
  conversationId: Uuid

  # The unique identifier for the preset that this selection was copied from.
  inheritsFromId: Uuid

  # The unique identifier of the place.
  placeId: Uuid

  # The description of the place.
  placeDescription: String

  # The unique identifier for the food.
  foodId: Float

  # The description of the food.
  foodDescription: String
  foodIdSource: InputSource
  category: FoodSelectionCategory

  # The unique identifier for the brand.
  brandId: Uuid

  # The description of the brand.
  brandDescription: String

  # The unique name for the chemical change, if mentioned.
  chemicalChangeName: String

  # The unique name for the physical change, if mentioned.
  physicalChangeName: String

  # The unique identifier for the unit of measure, if mentioned.
  unitOfMeasureId: Int

  # The numeric component for describing quantity of food: e.x. 1/4 in 1/4 cup, 200 in 200 grams.
  unitQuantity: Float

  # The price paid for the food selection.
  unitPrice: Float

  # The total mass of the food in grams.
  mass: Float
  massSource: InputSource

  # A number that represents the person’s attitude or feelings about the food selection.
  ratingValue: Float

  # The date the food selection occurred, local to the person.
  date: Date

  # The time the food selection occurred, local to the person.
  time: Time

  # The original text of the food selection.
  original: String

  # Flags this food selection as something that was mentioned as an omission.
  omission: Boolean

  # The time this object was created.
  createdAt: Datetime

  # The time this object was last updated.
  updatedAt: Datetime
}

# A connection to a list of `FoodSelection` values.
type FoodSelectionsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `FoodSelection` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `FoodSelection` and cursor to aid in pagination.
  edges: [FoodSelectionsEdge]

  # A list of `FoodSelection` objects.
  nodes: [FoodSelection!]
}

# A `FoodSelection` edge in the connection.
type FoodSelectionsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `FoodSelection` at the end of the edge.
  node: FoodSelection!
}

# Methods to use when ordering `FoodSelection`.
enum FoodSelectionsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  CONVERSATION_ID_ASC
  CONVERSATION_ID_DESC
  INHERITS_FROM_ID_ASC
  INHERITS_FROM_ID_DESC
  PLACE_ID_ASC
  PLACE_ID_DESC
  PLACE_DESCRIPTION_ASC
  PLACE_DESCRIPTION_DESC
  FOOD_ID_ASC
  FOOD_ID_DESC
  FOOD_DESCRIPTION_ASC
  FOOD_DESCRIPTION_DESC
  FOOD_ID_SOURCE_ASC
  FOOD_ID_SOURCE_DESC
  CATEGORY_ASC
  CATEGORY_DESC
  BRAND_ID_ASC
  BRAND_ID_DESC
  BRAND_DESCRIPTION_ASC
  BRAND_DESCRIPTION_DESC
  CHEMICAL_CHANGE_NAME_ASC
  CHEMICAL_CHANGE_NAME_DESC
  PHYSICAL_CHANGE_NAME_ASC
  PHYSICAL_CHANGE_NAME_DESC
  UNIT_OF_MEASURE_ID_ASC
  UNIT_OF_MEASURE_ID_DESC
  UNIT_QUANTITY_ASC
  UNIT_QUANTITY_DESC
  UNIT_PRICE_ASC
  UNIT_PRICE_DESC
  MASS_ASC
  MASS_DESC
  MASS_SOURCE_ASC
  MASS_SOURCE_DESC
  RATING_VALUE_ASC
  RATING_VALUE_DESC
  DATE_ASC
  DATE_DESC
  TIME_ASC
  TIME_DESC
  ORIGINAL_ASC
  ORIGINAL_DESC
  OMISSION_ASC
  OMISSION_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

# Methods to use when ordering `Food`.
enum FoodsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  FOOD_GROUP_ID_ASC
  FOOD_GROUP_ID_DESC
  BRAND_NAME_ASC
  BRAND_NAME_DESC
  LONG_DESCRIPTION_ASC
  LONG_DESCRIPTION_DESC
  SHORT_DESCRIPTION_ASC
  SHORT_DESCRIPTION_DESC
  REFUSE_DESCRIPTION_ASC
  REFUSE_DESCRIPTION_DESC
  REFUSE_ASC
  REFUSE_DESC
  PROTEIN_FACTOR_ASC
  PROTEIN_FACTOR_DESC
  FAT_FACTOR_ASC
  FAT_FACTOR_DESC
  CARB_FACTOR_ASC
  CARB_FACTOR_DESC
  WATER_ASC
  WATER_DESC
  CALORIES_ASC
  CALORIES_DESC
  PROTEIN_ASC
  PROTEIN_DESC
  FAT_ASC
  FAT_DESC
  ASH_ASC
  ASH_DESC
  CARBS_ASC
  CARBS_DESC
  FIBER_ASC
  FIBER_DESC
  SUGAR_ASC
  SUGAR_DESC
  CALCIUM_ASC
  CALCIUM_DESC
  IRON_ASC
  IRON_DESC
  MAGNESIUM_ASC
  MAGNESIUM_DESC
  PHOSPHORUS_ASC
  PHOSPHORUS_DESC
  POTASSIUM_ASC
  POTASSIUM_DESC
  SODIUM_ASC
  SODIUM_DESC
  ZINC_ASC
  ZINC_DESC
  COPPER_ASC
  COPPER_DESC
  MANGANESE_ASC
  MANGANESE_DESC
  SELENIUM_ASC
  SELENIUM_DESC
  VITAMIN_C_ASC
  VITAMIN_C_DESC
  THIAMIN_ASC
  THIAMIN_DESC
  RIBOFLAVIN_ASC
  RIBOFLAVIN_DESC
  NIACIN_ASC
  NIACIN_DESC
  PANTO_ACID_ASC
  PANTO_ACID_DESC
  VITAMIN_B6_ASC
  VITAMIN_B6_DESC
  FOLATE_ASC
  FOLATE_DESC
  FOLIC_ACID_ASC
  FOLIC_ACID_DESC
  FOOD_FOLATE_ASC
  FOOD_FOLATE_DESC
  FOLATE_DFE_ASC
  FOLATE_DFE_DESC
  CHOLINE_ASC
  CHOLINE_DESC
  VITAMIN_B12_ASC
  VITAMIN_B12_DESC
  VITAMIN_A_IU_ASC
  VITAMIN_A_IU_DESC
  VITAMIN_A_RAE_ASC
  VITAMIN_A_RAE_DESC
  RETINOL_ASC
  RETINOL_DESC
  ALPHA_CAROT_ASC
  ALPHA_CAROT_DESC
  BETA_CAROT_ASC
  BETA_CAROT_DESC
  BETA_CRYPT_ASC
  BETA_CRYPT_DESC
  LYCOPENE_ASC
  LYCOPENE_DESC
  LUT_ZEA_ASC
  LUT_ZEA_DESC
  VITAMIN_E_ASC
  VITAMIN_E_DESC
  VITAMIN_D_MCG_ASC
  VITAMIN_D_MCG_DESC
  VITAMIN_D_IU_ASC
  VITAMIN_D_IU_DESC
  VITAMIN_K_ASC
  VITAMIN_K_DESC
  FAT_SAT_ASC
  FAT_SAT_DESC
  FAT_MONO_ASC
  FAT_MONO_DESC
  FAT_POLY_ASC
  FAT_POLY_DESC
  CHOLESTEROL_ASC
  CHOLESTEROL_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

type GeocodeResult {
  geoRating: Int
  lon: Float
  lat: Float
  streetNumber: Int
  streetName: String
  streetType: String
  city: String
  state: String
  zip: String
}

# Describes who input the data for an adjacent column. Clerk is someone who
# administers the database, machine is a machine learning algorithm, user is a
# person who manually input the data through the app.
enum InputSource {
  CLERK
  MACHINE
  USER
}

type JwtToken {
  role: String
  userId: Uuid
  exp: Int
}

# Contains a factor for converting a volume or count unit into grams for a given food item and physical form.
type MassConversion implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!
  rowId: Int!

  # The unique identifier for the food item.
  foodId: Float!

  # The unique identifier for the initial unit of measure which is a volume or count unit, e.x. liter, drumstick, piece, box.
  unitOfMeasureId: Int!

  # The unique name for the physical form or process the food is in.
  physicalChangeName: String

  # The mass equivalent in grams.
  mass: Float

  # Reads a single `Food` that is related to this `MassConversion`.
  foodByFoodId: Food

  # Reads a single `UnitOfMeasure` that is related to this `MassConversion`.
  unitOfMeasureByUnitOfMeasureId: UnitOfMeasure

  # Reads a single `PhysicalChange` that is related to this `MassConversion`.
  physicalChangeByPhysicalChangeName: PhysicalChange
}

# A condition to be used against `MassConversion` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input MassConversionCondition {
  # Checks for equality with the object’s `rowId` field.
  rowId: Int

  # Checks for equality with the object’s `foodId` field.
  foodId: Float

  # Checks for equality with the object’s `unitOfMeasureId` field.
  unitOfMeasureId: Int

  # Checks for equality with the object’s `physicalChangeName` field.
  physicalChangeName: String

  # Checks for equality with the object’s `mass` field.
  mass: Float
}

# Contains a factor for converting a volume or count unit into grams for a given food item and physical form.
input MassConversionInput {
  rowId: Int

  # The unique identifier for the food item.
  foodId: Float!

  # The unique identifier for the initial unit of measure which is a volume or count unit, e.x. liter, drumstick, piece, box.
  unitOfMeasureId: Int!

  # The unique name for the physical form or process the food is in.
  physicalChangeName: String

  # The mass equivalent in grams.
  mass: Float
}

# Represents an update to a `MassConversion`. Fields that are set will be updated.
input MassConversionPatch {
  rowId: Int

  # The unique identifier for the food item.
  foodId: Float

  # The unique identifier for the initial unit of measure which is a volume or count unit, e.x. liter, drumstick, piece, box.
  unitOfMeasureId: Int

  # The unique name for the physical form or process the food is in.
  physicalChangeName: String

  # The mass equivalent in grams.
  mass: Float
}

# A connection to a list of `MassConversion` values.
type MassConversionsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `MassConversion` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `MassConversion` and cursor to aid in pagination.
  edges: [MassConversionsEdge]

  # A list of `MassConversion` objects.
  nodes: [MassConversion!]
}

# A `MassConversion` edge in the connection.
type MassConversionsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `MassConversion` at the end of the edge.
  node: MassConversion!
}

# Methods to use when ordering `MassConversion`.
enum MassConversionsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  FOOD_ID_ASC
  FOOD_ID_DESC
  UNIT_OF_MEASURE_ID_ASC
  UNIT_OF_MEASURE_ID_DESC
  PHYSICAL_CHANGE_NAME_ASC
  PHYSICAL_CHANGE_NAME_DESC
  MASS_ASC
  MASS_DESC
}

# A message sent by a person to the agent.
type Message implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # The unique identifier for the message which is provided by the agent.
  rowId: Uuid!

  # The unique identifier for the conversation session.
  conversationId: Uuid!

  # The agent’s language.
  lang: String

  # Name of the user intention determined by the agent.
  intent: String

  # Matching score for the intent.
  score: Float

  # Status of the agent request.
  status: String

  # The time this object was created.
  createdAt: Datetime

  # Reads a single `Conversation` that is related to this `Message`.
  conversationByConversationId: Conversation
}

# A condition to be used against `Message` object types. All fields are tested for equality and combined with a logical ‘and.’
input MessageCondition {
  # Checks for equality with the object’s `rowId` field.
  rowId: Uuid

  # Checks for equality with the object’s `conversationId` field.
  conversationId: Uuid

  # Checks for equality with the object’s `lang` field.
  lang: String

  # Checks for equality with the object’s `intent` field.
  intent: String

  # Checks for equality with the object’s `score` field.
  score: Float

  # Checks for equality with the object’s `status` field.
  status: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime
}

# A message sent by a person to the agent.
input MessageInput {
  # The unique identifier for the message which is provided by the agent.
  rowId: Uuid

  # The unique identifier for the conversation session.
  conversationId: Uuid!

  # The agent’s language.
  lang: String

  # Name of the user intention determined by the agent.
  intent: String

  # Matching score for the intent.
  score: Float

  # Status of the agent request.
  status: String

  # The time this object was created.
  createdAt: Datetime
}

# Represents an update to a `Message`. Fields that are set will be updated.
input MessagePatch {
  # The unique identifier for the message which is provided by the agent.
  rowId: Uuid

  # The unique identifier for the conversation session.
  conversationId: Uuid

  # The agent’s language.
  lang: String

  # Name of the user intention determined by the agent.
  intent: String

  # Matching score for the intent.
  score: Float

  # Status of the agent request.
  status: String

  # The time this object was created.
  createdAt: Datetime
}

# A connection to a list of `Message` values.
type MessagesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Message` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Message` and cursor to aid in pagination.
  edges: [MessagesEdge]

  # A list of `Message` objects.
  nodes: [Message!]
}

# A `Message` edge in the connection.
type MessagesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Message` at the end of the edge.
  node: Message!
}

# Methods to use when ordering `Message`.
enum MessagesOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  CONVERSATION_ID_ASC
  CONVERSATION_ID_DESC
  LANG_ASC
  LANG_DESC
  INTENT_ASC
  INTENT_DESC
  SCORE_ASC
  SCORE_DESC
  STATUS_ASC
  STATUS_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
}

# The root mutation type which contains root level fields which mutate data.
type Mutation {
  # Creates a JWT token that will securely identify a person and give them certain permissions.
  authenticateUser(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: AuthenticateUserInput!
  ): AuthenticateUserPayload

  # Registers a single user and creates an account.
  registerUser(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: RegisterUserInput!
  ): RegisterUserPayload

  # Creates a single `Brand`.
  createBrand(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateBrandInput!
  ): CreateBrandPayload

  # Updates a single `Brand` using its globally unique id and a patch.
  updateBrand(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateBrandInput!
  ): UpdateBrandPayload

  # Updates a single `Brand` using a unique key and a patch.
  updateBrandByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateBrandByRowIdInput!
  ): UpdateBrandPayload

  # Updates a single `Brand` using a unique key and a patch.
  updateBrandByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateBrandByNameInput!
  ): UpdateBrandPayload

  # Updates a single `Brand` using a unique key and a patch.
  updateBrandByEmail(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateBrandByEmailInput!
  ): UpdateBrandPayload

  # Updates a single `Brand` using a unique key and a patch.
  updateBrandByPhone(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateBrandByPhoneInput!
  ): UpdateBrandPayload

  # Deletes a single `Brand` using its globally unique id.
  deleteBrand(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteBrandInput!
  ): DeleteBrandPayload

  # Deletes a single `Brand` using a unique key.
  deleteBrandByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteBrandByRowIdInput!
  ): DeleteBrandPayload

  # Deletes a single `Brand` using a unique key.
  deleteBrandByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteBrandByNameInput!
  ): DeleteBrandPayload

  # Deletes a single `Brand` using a unique key.
  deleteBrandByEmail(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteBrandByEmailInput!
  ): DeleteBrandPayload

  # Deletes a single `Brand` using a unique key.
  deleteBrandByPhone(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteBrandByPhoneInput!
  ): DeleteBrandPayload

  # Creates a single `ChemicalChange`.
  createChemicalChange(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateChemicalChangeInput!
  ): CreateChemicalChangePayload

  # Updates a single `ChemicalChange` using its globally unique id and a patch.
  updateChemicalChange(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateChemicalChangeInput!
  ): UpdateChemicalChangePayload

  # Updates a single `ChemicalChange` using a unique key and a patch.
  updateChemicalChangeByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateChemicalChangeByNameInput!
  ): UpdateChemicalChangePayload

  # Deletes a single `ChemicalChange` using its globally unique id.
  deleteChemicalChange(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteChemicalChangeInput!
  ): DeleteChemicalChangePayload

  # Deletes a single `ChemicalChange` using a unique key.
  deleteChemicalChangeByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteChemicalChangeByNameInput!
  ): DeleteChemicalChangePayload

  # Creates a single `Conversation`.
  createConversation(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateConversationInput!
  ): CreateConversationPayload

  # Updates a single `Conversation` using its globally unique id and a patch.
  updateConversation(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateConversationInput!
  ): UpdateConversationPayload

  # Updates a single `Conversation` using a unique key and a patch.
  updateConversationByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateConversationByRowIdInput!
  ): UpdateConversationPayload

  # Deletes a single `Conversation` using its globally unique id.
  deleteConversation(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteConversationInput!
  ): DeleteConversationPayload

  # Deletes a single `Conversation` using a unique key.
  deleteConversationByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteConversationByRowIdInput!
  ): DeleteConversationPayload

  # Creates a single `Food`.
  createFood(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateFoodInput!
  ): CreateFoodPayload

  # Updates a single `Food` using its globally unique id and a patch.
  updateFood(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateFoodInput!
  ): UpdateFoodPayload

  # Updates a single `Food` using a unique key and a patch.
  updateFoodByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateFoodByRowIdInput!
  ): UpdateFoodPayload

  # Deletes a single `Food` using its globally unique id.
  deleteFood(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteFoodInput!
  ): DeleteFoodPayload

  # Deletes a single `Food` using a unique key.
  deleteFoodByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteFoodByRowIdInput!
  ): DeleteFoodPayload

  # Creates a single `FoodGroup`.
  createFoodGroup(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateFoodGroupInput!
  ): CreateFoodGroupPayload

  # Updates a single `FoodGroup` using its globally unique id and a patch.
  updateFoodGroup(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateFoodGroupInput!
  ): UpdateFoodGroupPayload

  # Updates a single `FoodGroup` using a unique key and a patch.
  updateFoodGroupByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateFoodGroupByRowIdInput!
  ): UpdateFoodGroupPayload

  # Deletes a single `FoodGroup` using its globally unique id.
  deleteFoodGroup(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteFoodGroupInput!
  ): DeleteFoodGroupPayload

  # Deletes a single `FoodGroup` using a unique key.
  deleteFoodGroupByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteFoodGroupByRowIdInput!
  ): DeleteFoodGroupPayload

  # Creates a single `FoodNutrient`.
  createFoodNutrient(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateFoodNutrientInput!
  ): CreateFoodNutrientPayload

  # Updates a single `FoodNutrient` using its globally unique id and a patch.
  updateFoodNutrient(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateFoodNutrientInput!
  ): UpdateFoodNutrientPayload

  # Updates a single `FoodNutrient` using a unique key and a patch.
  updateFoodNutrientByFoodIdAndNutrientId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateFoodNutrientByFoodIdAndNutrientIdInput!
  ): UpdateFoodNutrientPayload

  # Deletes a single `FoodNutrient` using its globally unique id.
  deleteFoodNutrient(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteFoodNutrientInput!
  ): DeleteFoodNutrientPayload

  # Deletes a single `FoodNutrient` using a unique key.
  deleteFoodNutrientByFoodIdAndNutrientId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteFoodNutrientByFoodIdAndNutrientIdInput!
  ): DeleteFoodNutrientPayload

  # Creates a single `FoodSelection`.
  createFoodSelection(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateFoodSelectionInput!
  ): CreateFoodSelectionPayload

  # Updates a single `FoodSelection` using its globally unique id and a patch.
  updateFoodSelection(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateFoodSelectionInput!
  ): UpdateFoodSelectionPayload

  # Updates a single `FoodSelection` using a unique key and a patch.
  updateFoodSelectionByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateFoodSelectionByRowIdInput!
  ): UpdateFoodSelectionPayload

  # Deletes a single `FoodSelection` using its globally unique id.
  deleteFoodSelection(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteFoodSelectionInput!
  ): DeleteFoodSelectionPayload

  # Deletes a single `FoodSelection` using a unique key.
  deleteFoodSelectionByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteFoodSelectionByRowIdInput!
  ): DeleteFoodSelectionPayload

  # Creates a single `MassConversion`.
  createMassConversion(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateMassConversionInput!
  ): CreateMassConversionPayload

  # Updates a single `MassConversion` using its globally unique id and a patch.
  updateMassConversion(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateMassConversionInput!
  ): UpdateMassConversionPayload

  # Updates a single `MassConversion` using a unique key and a patch.
  updateMassConversionByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateMassConversionByRowIdInput!
  ): UpdateMassConversionPayload

  # Updates a single `MassConversion` using a unique key and a patch.
  updateMassConversionByFoodIdAndUnitOfMeasureIdAndPhysicalChangeName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateMassConversionByFoodIdAndUnitOfMeasureIdAndPhysicalChangeNameInput!
  ): UpdateMassConversionPayload

  # Deletes a single `MassConversion` using its globally unique id.
  deleteMassConversion(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteMassConversionInput!
  ): DeleteMassConversionPayload

  # Deletes a single `MassConversion` using a unique key.
  deleteMassConversionByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteMassConversionByRowIdInput!
  ): DeleteMassConversionPayload

  # Deletes a single `MassConversion` using a unique key.
  deleteMassConversionByFoodIdAndUnitOfMeasureIdAndPhysicalChangeName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteMassConversionByFoodIdAndUnitOfMeasureIdAndPhysicalChangeNameInput!
  ): DeleteMassConversionPayload

  # Creates a single `Message`.
  createMessage(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateMessageInput!
  ): CreateMessagePayload

  # Updates a single `Message` using its globally unique id and a patch.
  updateMessage(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateMessageInput!
  ): UpdateMessagePayload

  # Updates a single `Message` using a unique key and a patch.
  updateMessageByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateMessageByRowIdInput!
  ): UpdateMessagePayload

  # Deletes a single `Message` using its globally unique id.
  deleteMessage(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteMessageInput!
  ): DeleteMessagePayload

  # Deletes a single `Message` using a unique key.
  deleteMessageByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteMessageByRowIdInput!
  ): DeleteMessagePayload

  # Creates a single `Nutrient`.
  createNutrient(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateNutrientInput!
  ): CreateNutrientPayload

  # Updates a single `Nutrient` using its globally unique id and a patch.
  updateNutrient(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateNutrientInput!
  ): UpdateNutrientPayload

  # Updates a single `Nutrient` using a unique key and a patch.
  updateNutrientByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateNutrientByRowIdInput!
  ): UpdateNutrientPayload

  # Deletes a single `Nutrient` using its globally unique id.
  deleteNutrient(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteNutrientInput!
  ): DeleteNutrientPayload

  # Deletes a single `Nutrient` using a unique key.
  deleteNutrientByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteNutrientByRowIdInput!
  ): DeleteNutrientPayload

  # Creates a single `PhysicalChange`.
  createPhysicalChange(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreatePhysicalChangeInput!
  ): CreatePhysicalChangePayload

  # Updates a single `PhysicalChange` using its globally unique id and a patch.
  updatePhysicalChange(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePhysicalChangeInput!
  ): UpdatePhysicalChangePayload

  # Updates a single `PhysicalChange` using a unique key and a patch.
  updatePhysicalChangeByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePhysicalChangeByNameInput!
  ): UpdatePhysicalChangePayload

  # Deletes a single `PhysicalChange` using its globally unique id.
  deletePhysicalChange(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePhysicalChangeInput!
  ): DeletePhysicalChangePayload

  # Deletes a single `PhysicalChange` using a unique key.
  deletePhysicalChangeByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePhysicalChangeByNameInput!
  ): DeletePhysicalChangePayload

  # Creates a single `Place`.
  createPlace(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreatePlaceInput!
  ): CreatePlacePayload

  # Updates a single `Place` using its globally unique id and a patch.
  updatePlace(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePlaceInput!
  ): UpdatePlacePayload

  # Updates a single `Place` using a unique key and a patch.
  updatePlaceByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePlaceByRowIdInput!
  ): UpdatePlacePayload

  # Updates a single `Place` using a unique key and a patch.
  updatePlaceByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePlaceByNameInput!
  ): UpdatePlacePayload

  # Deletes a single `Place` using its globally unique id.
  deletePlace(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePlaceInput!
  ): DeletePlacePayload

  # Deletes a single `Place` using a unique key.
  deletePlaceByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePlaceByRowIdInput!
  ): DeletePlacePayload

  # Deletes a single `Place` using a unique key.
  deletePlaceByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePlaceByNameInput!
  ): DeletePlacePayload

  # Creates a single `Preset`.
  createPreset(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreatePresetInput!
  ): CreatePresetPayload

  # Updates a single `Preset` using its globally unique id and a patch.
  updatePreset(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePresetInput!
  ): UpdatePresetPayload

  # Updates a single `Preset` using a unique key and a patch.
  updatePresetByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePresetByRowIdInput!
  ): UpdatePresetPayload

  # Updates a single `Preset` using a unique key and a patch.
  updatePresetByUserIdAndName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePresetByUserIdAndNameInput!
  ): UpdatePresetPayload

  # Deletes a single `Preset` using its globally unique id.
  deletePreset(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePresetInput!
  ): DeletePresetPayload

  # Deletes a single `Preset` using a unique key.
  deletePresetByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePresetByRowIdInput!
  ): DeletePresetPayload

  # Deletes a single `Preset` using a unique key.
  deletePresetByUserIdAndName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePresetByUserIdAndNameInput!
  ): DeletePresetPayload

  # Creates a single `PresetSelection`.
  createPresetSelection(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreatePresetSelectionInput!
  ): CreatePresetSelectionPayload

  # Updates a single `PresetSelection` using its globally unique id and a patch.
  updatePresetSelection(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePresetSelectionInput!
  ): UpdatePresetSelectionPayload

  # Updates a single `PresetSelection` using a unique key and a patch.
  updatePresetSelectionByPresetIdAndSelectionId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePresetSelectionByPresetIdAndSelectionIdInput!
  ): UpdatePresetSelectionPayload

  # Deletes a single `PresetSelection` using its globally unique id.
  deletePresetSelection(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePresetSelectionInput!
  ): DeletePresetSelectionPayload

  # Deletes a single `PresetSelection` using a unique key.
  deletePresetSelectionByPresetIdAndSelectionId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePresetSelectionByPresetIdAndSelectionIdInput!
  ): DeletePresetSelectionPayload

  # Creates a single `UnitOfMeasure`.
  createUnitOfMeasure(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateUnitOfMeasureInput!
  ): CreateUnitOfMeasurePayload

  # Updates a single `UnitOfMeasure` using its globally unique id and a patch.
  updateUnitOfMeasure(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateUnitOfMeasureInput!
  ): UpdateUnitOfMeasurePayload

  # Updates a single `UnitOfMeasure` using a unique key and a patch.
  updateUnitOfMeasureByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateUnitOfMeasureByRowIdInput!
  ): UpdateUnitOfMeasurePayload

  # Updates a single `UnitOfMeasure` using a unique key and a patch.
  updateUnitOfMeasureByFullName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateUnitOfMeasureByFullNameInput!
  ): UpdateUnitOfMeasurePayload

  # Updates a single `UnitOfMeasure` using a unique key and a patch.
  updateUnitOfMeasureByShortName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateUnitOfMeasureByShortNameInput!
  ): UpdateUnitOfMeasurePayload

  # Updates a single `UnitOfMeasure` using a unique key and a patch.
  updateUnitOfMeasureByUsdaKey(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateUnitOfMeasureByUsdaKeyInput!
  ): UpdateUnitOfMeasurePayload

  # Deletes a single `UnitOfMeasure` using its globally unique id.
  deleteUnitOfMeasure(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteUnitOfMeasureInput!
  ): DeleteUnitOfMeasurePayload

  # Deletes a single `UnitOfMeasure` using a unique key.
  deleteUnitOfMeasureByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteUnitOfMeasureByRowIdInput!
  ): DeleteUnitOfMeasurePayload

  # Deletes a single `UnitOfMeasure` using a unique key.
  deleteUnitOfMeasureByFullName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteUnitOfMeasureByFullNameInput!
  ): DeleteUnitOfMeasurePayload

  # Deletes a single `UnitOfMeasure` using a unique key.
  deleteUnitOfMeasureByShortName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteUnitOfMeasureByShortNameInput!
  ): DeleteUnitOfMeasurePayload

  # Deletes a single `UnitOfMeasure` using a unique key.
  deleteUnitOfMeasureByUsdaKey(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteUnitOfMeasureByUsdaKeyInput!
  ): DeleteUnitOfMeasurePayload

  # Creates a single `User`.
  createUser(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateUserInput!
  ): CreateUserPayload

  # Updates a single `User` using its globally unique id and a patch.
  updateUser(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateUserInput!
  ): UpdateUserPayload

  # Updates a single `User` using a unique key and a patch.
  updateUserByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateUserByRowIdInput!
  ): UpdateUserPayload

  # Updates a single `User` using a unique key and a patch.
  updateUserByPhone(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateUserByPhoneInput!
  ): UpdateUserPayload

  # Deletes a single `User` using its globally unique id.
  deleteUser(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteUserInput!
  ): DeleteUserPayload

  # Deletes a single `User` using a unique key.
  deleteUserByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteUserByRowIdInput!
  ): DeleteUserPayload

  # Deletes a single `User` using a unique key.
  deleteUserByPhone(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteUserByPhoneInput!
  ): DeleteUserPayload
}

# A connection to a list of `Place` values.
type NearbyPlacesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Place` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Place` and cursor to aid in pagination.
  edges: [NearbyPlacesEdge]

  # A list of `Place` objects.
  nodes: [Place]
}

# A `Place` edge in the connection.
type NearbyPlacesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Place` at the end of the edge.
  node: Place
}

# Methods to use when ordering `Place`.
enum NearbyPlacesOrderBy {
  NATURAL
}

# An object with a globally unique `ID`.
interface Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!
}

# A support table to the food_nutrient table. It provides the 3-digit nutrient
# code, unit of measure, INFOODS tagname, and description.
type Nutrient implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # Unique 3-digit identifier code for a nutrient.
  rowId: Float!

  # The USDA key for the unit of measure.
  unitOfMeasureUsdaKey: String!

  # International Network of Food Data Systems (INFOODS) Tagnames. A unique
  # abbreviation for a nutrient/food component developed by INFOODS to aid in the
  # interchange of data.
  shortName: String

  # Name of nutrient/food component.
  name: String!

  # Reads a single `UnitOfMeasure` that is related to this `Nutrient`.
  unitOfMeasureByUnitOfMeasureUsdaKey: UnitOfMeasure

  # Reads and enables pagination through a set of `FoodNutrient`.
  foodNutrientsByNutrientId(
    # The method to use when ordering `FoodNutrient`.
    orderBy: FoodNutrientsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: FoodNutrientCondition
  ): FoodNutrientsConnection
}

# A condition to be used against `Nutrient` object types. All fields are tested
# for equality and combined with a logical ‘and.’
input NutrientCondition {
  # Checks for equality with the object’s `rowId` field.
  rowId: Float

  # Checks for equality with the object’s `unitOfMeasureUsdaKey` field.
  unitOfMeasureUsdaKey: String

  # Checks for equality with the object’s `shortName` field.
  shortName: String

  # Checks for equality with the object’s `name` field.
  name: String
}

# A support table to the food_nutrient table. It provides the 3-digit nutrient
# code, unit of measure, INFOODS tagname, and description.
input NutrientInput {
  # Unique 3-digit identifier code for a nutrient.
  rowId: Float!

  # The USDA key for the unit of measure.
  unitOfMeasureUsdaKey: String!

  # International Network of Food Data Systems (INFOODS) Tagnames. A unique
  # abbreviation for a nutrient/food component developed by INFOODS to aid in the
  # interchange of data.
  shortName: String

  # Name of nutrient/food component.
  name: String!
}

# Represents an update to a `Nutrient`. Fields that are set will be updated.
input NutrientPatch {
  # Unique 3-digit identifier code for a nutrient.
  rowId: Float

  # The USDA key for the unit of measure.
  unitOfMeasureUsdaKey: String

  # International Network of Food Data Systems (INFOODS) Tagnames. A unique
  # abbreviation for a nutrient/food component developed by INFOODS to aid in the
  # interchange of data.
  shortName: String

  # Name of nutrient/food component.
  name: String
}

# A connection to a list of `Nutrient` values.
type NutrientsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Nutrient` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Nutrient` and cursor to aid in pagination.
  edges: [NutrientsEdge]

  # A list of `Nutrient` objects.
  nodes: [Nutrient!]
}

# A `Nutrient` edge in the connection.
type NutrientsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Nutrient` at the end of the edge.
  node: Nutrient!
}

# Methods to use when ordering `Nutrient`.
enum NutrientsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  UNIT_OF_MEASURE_USDA_KEY_ASC
  UNIT_OF_MEASURE_USDA_KEY_DESC
  SHORT_NAME_ASC
  SHORT_NAME_DESC
  NAME_ASC
  NAME_DESC
}

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: Cursor

  # When paginating forwards, the cursor to continue.
  endCursor: Cursor
}

# A physical process or form that a food item can exist in.
type PhysicalChange implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # The human-readable name of the physical change, e.x. diced, farmers cut, blended, liquid.
  name: String!
  description: String

  # The time this object was created.
  createdAt: Datetime

  # Reads and enables pagination through a set of `FoodSelection`.
  foodSelectionsByPhysicalChangeName(
    # The method to use when ordering `FoodSelection`.
    orderBy: FoodSelectionsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: FoodSelectionCondition
  ): FoodSelectionsConnection

  # Reads and enables pagination through a set of `MassConversion`.
  massConversionsByPhysicalChangeName(
    # The method to use when ordering `MassConversion`.
    orderBy: MassConversionsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: MassConversionCondition
  ): MassConversionsConnection
}

# A condition to be used against `PhysicalChange` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input PhysicalChangeCondition {
  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `description` field.
  description: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime
}

# A physical process or form that a food item can exist in.
input PhysicalChangeInput {
  # The human-readable name of the physical change, e.x. diced, farmers cut, blended, liquid.
  name: String!
  description: String

  # The time this object was created.
  createdAt: Datetime
}

# Represents an update to a `PhysicalChange`. Fields that are set will be updated.
input PhysicalChangePatch {
  # The human-readable name of the physical change, e.x. diced, farmers cut, blended, liquid.
  name: String
  description: String

  # The time this object was created.
  createdAt: Datetime
}

# A connection to a list of `PhysicalChange` values.
type PhysicalChangesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `PhysicalChange` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `PhysicalChange` and cursor to aid in pagination.
  edges: [PhysicalChangesEdge]

  # A list of `PhysicalChange` objects.
  nodes: [PhysicalChange!]
}

# A `PhysicalChange` edge in the connection.
type PhysicalChangesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `PhysicalChange` at the end of the edge.
  node: PhysicalChange!
}

# Methods to use when ordering `PhysicalChange`.
enum PhysicalChangesOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
}

# A place that has or sells food.
type Place implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # The unique identifier for the place.
  rowId: Uuid!

  # The unique identifier for the user who owns the place.
  ownerId: Uuid

  # The name of the person responsible for the place listing. This is a fallback for not having a registered user as owner id.
  ownerName: String

  # The place’s human-readable name.
  name: String!

  # The place’s primary email address.
  email: String

  # The place’s phone number.
  phone: String

  # The place’s external website url.
  url: String

  # A confidence rating from the geocoder.
  geoRating: Int

  # The geographical longitude of the place.
  lon: Float

  # The geographical latitude of the place.
  lat: Float

  # The geographical street number of the place.
  streetNumber: Int

  # The geographical street name of the place.
  streetName: String

  # The geographical street type of the place.
  streetType: String

  # The city of the place.
  city: String

  # The geographical state of the place.
  state: String

  # The zip code of the place.
  zip: String

  # The time this object was created.
  createdAt: Datetime

  # The time this object was last updated.
  updatedAt: Datetime

  # Reads a single `User` that is related to this `Place`.
  userByOwnerId: User

  # Reads and enables pagination through a set of `FoodSelection`.
  foodSelectionsByPlaceId(
    # The method to use when ordering `FoodSelection`.
    orderBy: FoodSelectionsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: FoodSelectionCondition
  ): FoodSelectionsConnection
}

# A condition to be used against `Place` object types. All fields are tested for equality and combined with a logical ‘and.’
input PlaceCondition {
  # Checks for equality with the object’s `rowId` field.
  rowId: Uuid

  # Checks for equality with the object’s `ownerId` field.
  ownerId: Uuid

  # Checks for equality with the object’s `ownerName` field.
  ownerName: String

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `email` field.
  email: String

  # Checks for equality with the object’s `phone` field.
  phone: String

  # Checks for equality with the object’s `url` field.
  url: String

  # Checks for equality with the object’s `geoRating` field.
  geoRating: Int

  # Checks for equality with the object’s `lon` field.
  lon: Float

  # Checks for equality with the object’s `lat` field.
  lat: Float

  # Checks for equality with the object’s `streetNumber` field.
  streetNumber: Int

  # Checks for equality with the object’s `streetName` field.
  streetName: String

  # Checks for equality with the object’s `streetType` field.
  streetType: String

  # Checks for equality with the object’s `city` field.
  city: String

  # Checks for equality with the object’s `state` field.
  state: String

  # Checks for equality with the object’s `zip` field.
  zip: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# A place that has or sells food.
input PlaceInput {
  # The unique identifier for the place.
  rowId: Uuid

  # The unique identifier for the user who owns the place.
  ownerId: Uuid

  # The name of the person responsible for the place listing. This is a fallback for not having a registered user as owner id.
  ownerName: String

  # The place’s human-readable name.
  name: String!

  # The place’s primary email address.
  email: String

  # The place’s phone number.
  phone: String

  # The place’s external website url.
  url: String

  # A confidence rating from the geocoder.
  geoRating: Int

  # The geographical longitude of the place.
  lon: Float

  # The geographical latitude of the place.
  lat: Float

  # The geographical street number of the place.
  streetNumber: Int

  # The geographical street name of the place.
  streetName: String

  # The geographical street type of the place.
  streetType: String

  # The city of the place.
  city: String

  # The geographical state of the place.
  state: String

  # The zip code of the place.
  zip: String

  # The time this object was created.
  createdAt: Datetime

  # The time this object was last updated.
  updatedAt: Datetime
}

# Represents an update to a `Place`. Fields that are set will be updated.
input PlacePatch {
  # The unique identifier for the place.
  rowId: Uuid

  # The unique identifier for the user who owns the place.
  ownerId: Uuid

  # The name of the person responsible for the place listing. This is a fallback for not having a registered user as owner id.
  ownerName: String

  # The place’s human-readable name.
  name: String

  # The place’s primary email address.
  email: String

  # The place’s phone number.
  phone: String

  # The place’s external website url.
  url: String

  # A confidence rating from the geocoder.
  geoRating: Int

  # The geographical longitude of the place.
  lon: Float

  # The geographical latitude of the place.
  lat: Float

  # The geographical street number of the place.
  streetNumber: Int

  # The geographical street name of the place.
  streetName: String

  # The geographical street type of the place.
  streetType: String

  # The city of the place.
  city: String

  # The geographical state of the place.
  state: String

  # The zip code of the place.
  zip: String

  # The time this object was created.
  createdAt: Datetime

  # The time this object was last updated.
  updatedAt: Datetime
}

# A connection to a list of `Place` values.
type PlacesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Place` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Place` and cursor to aid in pagination.
  edges: [PlacesEdge]

  # A list of `Place` objects.
  nodes: [Place!]
}

# A `Place` edge in the connection.
type PlacesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Place` at the end of the edge.
  node: Place!
}

# Methods to use when ordering `Place`.
enum PlacesOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  OWNER_ID_ASC
  OWNER_ID_DESC
  OWNER_NAME_ASC
  OWNER_NAME_DESC
  NAME_ASC
  NAME_DESC
  EMAIL_ASC
  EMAIL_DESC
  PHONE_ASC
  PHONE_DESC
  URL_ASC
  URL_DESC
  GEO_RATING_ASC
  GEO_RATING_DESC
  LON_ASC
  LON_DESC
  LAT_ASC
  LAT_DESC
  STREET_NUMBER_ASC
  STREET_NUMBER_DESC
  STREET_NAME_ASC
  STREET_NAME_DESC
  STREET_TYPE_ASC
  STREET_TYPE_DESC
  CITY_ASC
  CITY_DESC
  STATE_ASC
  STATE_DESC
  ZIP_ASC
  ZIP_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

# A preset group of food selections for convenience with recurring meals, shopping lists, etc..
type Preset implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # The unique identifier for the preset.
  rowId: Uuid!

  # The unique identifier for the person.
  userId: Uuid!

  # The unique identifier for the conversation.
  conversationId: Uuid!

  # A name for the preset which is unique per user id so it can be conveniently referenced.
  name: String

  # The time this object was created.
  createdAt: Datetime

  # Reads a single `User` that is related to this `Preset`.
  userByUserId: User

  # Reads a single `Conversation` that is related to this `Preset`.
  conversationByConversationId: Conversation

  # Reads and enables pagination through a set of `FoodSelection`.
  foodSelectionsByInheritsFromId(
    # The method to use when ordering `FoodSelection`.
    orderBy: FoodSelectionsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: FoodSelectionCondition
  ): FoodSelectionsConnection

  # Reads and enables pagination through a set of `PresetSelection`.
  presetSelectionsByPresetId(
    # The method to use when ordering `PresetSelection`.
    orderBy: PresetSelectionsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: PresetSelectionCondition
  ): PresetSelectionsConnection
}

# A condition to be used against `Preset` object types. All fields are tested for equality and combined with a logical ‘and.’
input PresetCondition {
  # Checks for equality with the object’s `rowId` field.
  rowId: Uuid

  # Checks for equality with the object’s `userId` field.
  userId: Uuid

  # Checks for equality with the object’s `conversationId` field.
  conversationId: Uuid

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime
}

# A preset group of food selections for convenience with recurring meals, shopping lists, etc..
input PresetInput {
  # The unique identifier for the preset.
  rowId: Uuid

  # The unique identifier for the person.
  userId: Uuid!

  # The unique identifier for the conversation.
  conversationId: Uuid!

  # A name for the preset which is unique per user id so it can be conveniently referenced.
  name: String

  # The time this object was created.
  createdAt: Datetime
}

# Represents an update to a `Preset`. Fields that are set will be updated.
input PresetPatch {
  # The unique identifier for the preset.
  rowId: Uuid

  # The unique identifier for the person.
  userId: Uuid

  # The unique identifier for the conversation.
  conversationId: Uuid

  # A name for the preset which is unique per user id so it can be conveniently referenced.
  name: String

  # The time this object was created.
  createdAt: Datetime
}

# A connection to a list of `Preset` values.
type PresetsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Preset` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Preset` and cursor to aid in pagination.
  edges: [PresetsEdge]

  # A list of `Preset` objects.
  nodes: [Preset!]
}

# A `Preset` edge in the connection.
type PresetsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Preset` at the end of the edge.
  node: Preset!
}

# A support table that connects a food selection to a named preset.
type PresetSelection implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # The unique identifier for the preset.
  presetId: Uuid!

  # The unique identifier for the food selection.
  selectionId: Uuid!

  # The time this object was created.
  createdAt: Datetime

  # Reads a single `Preset` that is related to this `PresetSelection`.
  presetByPresetId: Preset

  # Reads a single `FoodSelection` that is related to this `PresetSelection`.
  foodSelectionBySelectionId: FoodSelection
}

# A condition to be used against `PresetSelection` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input PresetSelectionCondition {
  # Checks for equality with the object’s `presetId` field.
  presetId: Uuid

  # Checks for equality with the object’s `selectionId` field.
  selectionId: Uuid

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime
}

# A support table that connects a food selection to a named preset.
input PresetSelectionInput {
  # The unique identifier for the preset.
  presetId: Uuid!

  # The unique identifier for the food selection.
  selectionId: Uuid!

  # The time this object was created.
  createdAt: Datetime
}

# Represents an update to a `PresetSelection`. Fields that are set will be updated.
input PresetSelectionPatch {
  # The unique identifier for the preset.
  presetId: Uuid

  # The unique identifier for the food selection.
  selectionId: Uuid

  # The time this object was created.
  createdAt: Datetime
}

# A connection to a list of `PresetSelection` values.
type PresetSelectionsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `PresetSelection` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `PresetSelection` and cursor to aid in pagination.
  edges: [PresetSelectionsEdge]

  # A list of `PresetSelection` objects.
  nodes: [PresetSelection!]
}

# A `PresetSelection` edge in the connection.
type PresetSelectionsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `PresetSelection` at the end of the edge.
  node: PresetSelection!
}

# Methods to use when ordering `PresetSelection`.
enum PresetSelectionsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  PRESET_ID_ASC
  PRESET_ID_DESC
  SELECTION_ID_ASC
  SELECTION_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
}

# Methods to use when ordering `Preset`.
enum PresetsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  CONVERSATION_ID_ASC
  CONVERSATION_ID_DESC
  NAME_ASC
  NAME_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
}

# The root query type which gives access points into the data universe.
type Query implements Node {
  # Fetches an object given its globally unique `ID`.
  node(
    # The globally unique `ID`.
    id: ID!
  ): Node

  # Gets the person who was identified by our JWT.
  currentPerson: User

  # Returns a geocoded result from an address
  geocoder(address: String): GeocodeResult

  # Returns a set of places within a given distance from a geographical point.
  nearbyPlaces(
    # The method to use when ordering `Place`.
    orderBy: NearbyPlacesOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int
    lon: Float
    lat: Float
    distance: Float
  ): NearbyPlacesConnection

  # Reads and enables pagination through a set of `Brand`.
  allBrands(
    # The method to use when ordering `Brand`.
    orderBy: BrandsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: BrandCondition
  ): BrandsConnection

  # Reads a single `Brand` using its globally unique `ID`.
  brand(
    # The globally unique `ID` to be used in selecting a single `Brand`.
    id: ID!
  ): Brand
  brandByRowId(
    # The unique identifier for the brand.
    rowId: Uuid!
  ): Brand
  brandByName(
    # The brand’s human-readable name.
    name: String!
  ): Brand
  brandByEmail(
    # The brand’s primary email address.
    email: String!
  ): Brand
  brandByPhone(
    # The brand’s phone number.
    phone: String!
  ): Brand

  # Reads and enables pagination through a set of `ChemicalChange`.
  allChemicalChanges(
    # The method to use when ordering `ChemicalChange`.
    orderBy: ChemicalChangesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: ChemicalChangeCondition
  ): ChemicalChangesConnection

  # Reads a single `ChemicalChange` using its globally unique `ID`.
  chemicalChange(
    # The globally unique `ID` to be used in selecting a single `ChemicalChange`.
    id: ID!
  ): ChemicalChange
  chemicalChangeByName(
    # The human-readable name of the chemical change, e.x. cooked, baked, fermented, dehydrated.
    name: String!
  ): ChemicalChange

  # Reads and enables pagination through a set of `Conversation`.
  allConversations(
    # The method to use when ordering `Conversation`.
    orderBy: ConversationsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: ConversationCondition
  ): ConversationsConnection

  # Reads a single `Conversation` using its globally unique `ID`.
  conversation(
    # The globally unique `ID` to be used in selecting a single `Conversation`.
    id: ID!
  ): Conversation
  conversationByRowId(
    # The unique identifier for the conversation which is provided by the agent.
    rowId: Uuid!
  ): Conversation

  # Reads and enables pagination through a set of `Food`.
  allFoods(
    # The method to use when ordering `Food`.
    orderBy: FoodsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: FoodCondition
  ): FoodsConnection

  # Reads a single `Food` using its globally unique `ID`.
  food(
    # The globally unique `ID` to be used in selecting a single `Food`.
    id: ID!
  ): Food
  foodByRowId(
    # 5-digit or 8-digit Nutrient Databank number that uniquely identifies a food item.
    rowId: Float!
  ): Food

  # Reads and enables pagination through a set of `FoodGroup`.
  allFoodGroups(
    # The method to use when ordering `FoodGroup`.
    orderBy: FoodGroupsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: FoodGroupCondition
  ): FoodGroupsConnection

  # Reads a single `FoodGroup` using its globally unique `ID`.
  foodGroup(
    # The globally unique `ID` to be used in selecting a single `FoodGroup`.
    id: ID!
  ): FoodGroup
  foodGroupByRowId(
    # 4-digit code identifying a food group. Only the first 2 digits are currently assigned.
    rowId: Float!
  ): FoodGroup

  # Reads and enables pagination through a set of `FoodNutrient`.
  allFoodNutrients(
    # The method to use when ordering `FoodNutrient`.
    orderBy: FoodNutrientsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: FoodNutrientCondition
  ): FoodNutrientsConnection

  # Reads a single `FoodNutrient` using its globally unique `ID`.
  foodNutrient(
    # The globally unique `ID` to be used in selecting a single `FoodNutrient`.
    id: ID!
  ): FoodNutrient
  foodNutrientByFoodIdAndNutrientId(
    # 5-digit or 8-digit Nutrient Databank number that uniquely identifies a food item.
    foodId: Float!

    # Unique 3-digit identifier code for a nutrient.
    nutrientId: Float!
  ): FoodNutrient

  # Reads and enables pagination through a set of `FoodSelection`.
  allFoodSelections(
    # The method to use when ordering `FoodSelection`.
    orderBy: FoodSelectionsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: FoodSelectionCondition
  ): FoodSelectionsConnection

  # Reads a single `FoodSelection` using its globally unique `ID`.
  foodSelection(
    # The globally unique `ID` to be used in selecting a single `FoodSelection`.
    id: ID!
  ): FoodSelection
  foodSelectionByRowId(
    # The food selection’s unique identifier.
    rowId: Uuid!
  ): FoodSelection

  # Reads and enables pagination through a set of `MassConversion`.
  allMassConversions(
    # The method to use when ordering `MassConversion`.
    orderBy: MassConversionsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: MassConversionCondition
  ): MassConversionsConnection

  # Reads a single `MassConversion` using its globally unique `ID`.
  massConversion(
    # The globally unique `ID` to be used in selecting a single `MassConversion`.
    id: ID!
  ): MassConversion
  massConversionByRowId(rowId: Int!): MassConversion
  massConversionByFoodIdAndUnitOfMeasureIdAndPhysicalChangeName(
    # The unique identifier for the food item.
    foodId: Float!

    # The unique identifier for the initial unit of measure which is a volume or
    # count unit, e.x. liter, drumstick, piece, box.
    unitOfMeasureId: Int!

    # The unique name for the physical form or process the food is in.
    physicalChangeName: String!
  ): MassConversion

  # Reads and enables pagination through a set of `Message`.
  allMessages(
    # The method to use when ordering `Message`.
    orderBy: MessagesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: MessageCondition
  ): MessagesConnection

  # Reads a single `Message` using its globally unique `ID`.
  message(
    # The globally unique `ID` to be used in selecting a single `Message`.
    id: ID!
  ): Message
  messageByRowId(
    # The unique identifier for the message which is provided by the agent.
    rowId: Uuid!
  ): Message

  # Reads and enables pagination through a set of `Nutrient`.
  allNutrients(
    # The method to use when ordering `Nutrient`.
    orderBy: NutrientsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: NutrientCondition
  ): NutrientsConnection

  # Reads a single `Nutrient` using its globally unique `ID`.
  nutrient(
    # The globally unique `ID` to be used in selecting a single `Nutrient`.
    id: ID!
  ): Nutrient
  nutrientByRowId(
    # Unique 3-digit identifier code for a nutrient.
    rowId: Float!
  ): Nutrient

  # Reads and enables pagination through a set of `PhysicalChange`.
  allPhysicalChanges(
    # The method to use when ordering `PhysicalChange`.
    orderBy: PhysicalChangesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: PhysicalChangeCondition
  ): PhysicalChangesConnection

  # Reads a single `PhysicalChange` using its globally unique `ID`.
  physicalChange(
    # The globally unique `ID` to be used in selecting a single `PhysicalChange`.
    id: ID!
  ): PhysicalChange
  physicalChangeByName(
    # The human-readable name of the physical change, e.x. diced, farmers cut, blended, liquid.
    name: String!
  ): PhysicalChange

  # Reads and enables pagination through a set of `Place`.
  allPlaces(
    # The method to use when ordering `Place`.
    orderBy: PlacesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: PlaceCondition
  ): PlacesConnection

  # Reads a single `Place` using its globally unique `ID`.
  place(
    # The globally unique `ID` to be used in selecting a single `Place`.
    id: ID!
  ): Place
  placeByRowId(
    # The unique identifier for the place.
    rowId: Uuid!
  ): Place
  placeByName(
    # The place’s human-readable name.
    name: String!
  ): Place

  # Reads and enables pagination through a set of `Preset`.
  allPresets(
    # The method to use when ordering `Preset`.
    orderBy: PresetsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: PresetCondition
  ): PresetsConnection

  # Reads a single `Preset` using its globally unique `ID`.
  preset(
    # The globally unique `ID` to be used in selecting a single `Preset`.
    id: ID!
  ): Preset
  presetByRowId(
    # The unique identifier for the preset.
    rowId: Uuid!
  ): Preset
  presetByUserIdAndName(
    # The unique identifier for the person.
    userId: Uuid!

    # A name for the preset which is unique per user id so it can be conveniently referenced.
    name: String!
  ): Preset

  # Reads and enables pagination through a set of `PresetSelection`.
  allPresetSelections(
    # The method to use when ordering `PresetSelection`.
    orderBy: PresetSelectionsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: PresetSelectionCondition
  ): PresetSelectionsConnection

  # Reads a single `PresetSelection` using its globally unique `ID`.
  presetSelection(
    # The globally unique `ID` to be used in selecting a single `PresetSelection`.
    id: ID!
  ): PresetSelection
  presetSelectionByPresetIdAndSelectionId(
    # The unique identifier for the preset.
    presetId: Uuid!

    # The unique identifier for the food selection.
    selectionId: Uuid!
  ): PresetSelection

  # Reads and enables pagination through a set of `UnitOfMeasure`.
  allUnitOfMeasures(
    # The method to use when ordering `UnitOfMeasure`.
    orderBy: UnitOfMeasuresOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: UnitOfMeasureCondition
  ): UnitOfMeasuresConnection

  # Reads a single `UnitOfMeasure` using its globally unique `ID`.
  unitOfMeasure(
    # The globally unique `ID` to be used in selecting a single `UnitOfMeasure`.
    id: ID!
  ): UnitOfMeasure
  unitOfMeasureByRowId(
    # The unique identifier for the unit of measure.
    rowId: Int!
  ): UnitOfMeasure
  unitOfMeasureByFullName(
    # The full name of the unit of measure, e.x. cup, milliliter, gram, whole.
    fullName: String!
  ): UnitOfMeasure
  unitOfMeasureByShortName(
    # The abbreviated or shortened name for the unit of measure, e.x. c, g, mg.
    shortName: String!
  ): UnitOfMeasure
  unitOfMeasureByUsdaKey(
    # The original unique string from the USDA NDB for a unit of measure. Typos
    # and inconsistent plurals and abbreviations led to duplicated entries of the
    # same unit (e.x. cup, cups, and c). This column preserves those unique references.
    usdaKey: String!
  ): UnitOfMeasure

  # Reads and enables pagination through a set of `User`.
  allUsers(
    # The method to use when ordering `User`.
    orderBy: UsersOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: UserCondition
  ): UsersConnection

  # Reads a single `User` using its globally unique `ID`.
  user(
    # The globally unique `ID` to be used in selecting a single `User`.
    id: ID!
  ): User
  userByRowId(
    # The user’s unique identifier.
    rowId: Uuid!
  ): User
  userByPhone(
    # A phone number. Phone numbers must be unique across all users and must match the E.164 numbering spec.
    phone: String!
  ): User

  # Exposes the root query type nested one level down. This is helpful for Relay 1
  # which can only query top level fields if they are in a particular form.
  query: Query!

  # The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  id: ID!
}

# All input for the `registerUser` mutation.
input RegisterUserInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  name: String!
  phone: String!
  address: String!
}

# The output of our `registerUser` mutation.
type RegisterUserPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  authenticateUserResult: AuthenticateUserResult

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# The exact time of day, does not include the date. May or may not have a timezone offset.
scalar Time

# A unit of measure used to quantify a food selection.
type UnitOfMeasure implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # The unique identifier for the unit of measure.
  rowId: Int!

  # The full name of the unit of measure, e.x. cup, milliliter, gram, whole.
  fullName: String

  # The abbreviated or shortened name for the unit of measure, e.x. c, g, mg.
  shortName: String

  # A support column for resolving duplicates and typos from units referenced in the USDA NDB.
  shortNameRef: String

  # The original unique string from the USDA NDB for a unit of measure. Typos and
  # inconsistent plurals and abbreviations led to duplicated entries of the same
  # unit (e.x. cup, cups, and c). This column preserves those unique references.
  usdaKey: String
  unitCategory: UnitOfMeasureCategory

  # The number to multiply by to convert the unit into an International System of
  # Units base equivalent. Converts mass to grams, volume to liters, energy to
  # gram calories, length to meters, and temperature to celsius. Does not apply to
  # convenience, count, or time units.
  siFactor: Float

  # Reads a single `UnitOfMeasure` that is related to this `UnitOfMeasure`.
  unitOfMeasureByShortNameRef: UnitOfMeasure

  # Reads and enables pagination through a set of `UnitOfMeasure`.
  unitOfMeasuresByShortNameRef(
    # The method to use when ordering `UnitOfMeasure`.
    orderBy: UnitOfMeasuresOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: UnitOfMeasureCondition
  ): UnitOfMeasuresConnection

  # Reads and enables pagination through a set of `FoodSelection`.
  foodSelectionsByUnitOfMeasureId(
    # The method to use when ordering `FoodSelection`.
    orderBy: FoodSelectionsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: FoodSelectionCondition
  ): FoodSelectionsConnection

  # Reads and enables pagination through a set of `MassConversion`.
  massConversionsByUnitOfMeasureId(
    # The method to use when ordering `MassConversion`.
    orderBy: MassConversionsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: MassConversionCondition
  ): MassConversionsConnection

  # Reads and enables pagination through a set of `Nutrient`.
  nutrientsByUnitOfMeasureUsdaKey(
    # The method to use when ordering `Nutrient`.
    orderBy: NutrientsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: NutrientCondition
  ): NutrientsConnection
}

# The category of unit of measure. Convenience is used for USDA serving size units
# that are a preset amount like 3/4 cup. Count is when the unit is an item like 1
# drumstick or 1 slice of pizza.
enum UnitOfMeasureCategory {
  CONVENIENCE
  COUNT
  ENERGY
  LENGTH
  MASS
  TEMPERATURE
  TIME
  VOLUME
}

# A condition to be used against `UnitOfMeasure` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input UnitOfMeasureCondition {
  # Checks for equality with the object’s `rowId` field.
  rowId: Int

  # Checks for equality with the object’s `fullName` field.
  fullName: String

  # Checks for equality with the object’s `shortName` field.
  shortName: String

  # Checks for equality with the object’s `shortNameRef` field.
  shortNameRef: String

  # Checks for equality with the object’s `usdaKey` field.
  usdaKey: String

  # Checks for equality with the object’s `unitCategory` field.
  unitCategory: UnitOfMeasureCategory

  # Checks for equality with the object’s `siFactor` field.
  siFactor: Float
}

# A unit of measure used to quantify a food selection.
input UnitOfMeasureInput {
  # The unique identifier for the unit of measure.
  rowId: Int

  # The full name of the unit of measure, e.x. cup, milliliter, gram, whole.
  fullName: String

  # The abbreviated or shortened name for the unit of measure, e.x. c, g, mg.
  shortName: String

  # A support column for resolving duplicates and typos from units referenced in the USDA NDB.
  shortNameRef: String

  # The original unique string from the USDA NDB for a unit of measure. Typos and
  # inconsistent plurals and abbreviations led to duplicated entries of the same
  # unit (e.x. cup, cups, and c). This column preserves those unique references.
  usdaKey: String
  unitCategory: UnitOfMeasureCategory

  # The number to multiply by to convert the unit into an International System of
  # Units base equivalent. Converts mass to grams, volume to liters, energy to
  # gram calories, length to meters, and temperature to celsius. Does not apply to
  # convenience, count, or time units.
  siFactor: Float
}

# Represents an update to a `UnitOfMeasure`. Fields that are set will be updated.
input UnitOfMeasurePatch {
  # The unique identifier for the unit of measure.
  rowId: Int

  # The full name of the unit of measure, e.x. cup, milliliter, gram, whole.
  fullName: String

  # The abbreviated or shortened name for the unit of measure, e.x. c, g, mg.
  shortName: String

  # A support column for resolving duplicates and typos from units referenced in the USDA NDB.
  shortNameRef: String

  # The original unique string from the USDA NDB for a unit of measure. Typos and
  # inconsistent plurals and abbreviations led to duplicated entries of the same
  # unit (e.x. cup, cups, and c). This column preserves those unique references.
  usdaKey: String
  unitCategory: UnitOfMeasureCategory

  # The number to multiply by to convert the unit into an International System of
  # Units base equivalent. Converts mass to grams, volume to liters, energy to
  # gram calories, length to meters, and temperature to celsius. Does not apply to
  # convenience, count, or time units.
  siFactor: Float
}

# A connection to a list of `UnitOfMeasure` values.
type UnitOfMeasuresConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `UnitOfMeasure` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `UnitOfMeasure` and cursor to aid in pagination.
  edges: [UnitOfMeasuresEdge]

  # A list of `UnitOfMeasure` objects.
  nodes: [UnitOfMeasure!]
}

# A `UnitOfMeasure` edge in the connection.
type UnitOfMeasuresEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `UnitOfMeasure` at the end of the edge.
  node: UnitOfMeasure!
}

# Methods to use when ordering `UnitOfMeasure`.
enum UnitOfMeasuresOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  FULL_NAME_ASC
  FULL_NAME_DESC
  SHORT_NAME_ASC
  SHORT_NAME_DESC
  SHORT_NAME_REF_ASC
  SHORT_NAME_REF_DESC
  USDA_KEY_ASC
  USDA_KEY_DESC
  UNIT_CATEGORY_ASC
  UNIT_CATEGORY_DESC
  SI_FACTOR_ASC
  SI_FACTOR_DESC
}

# All input for the `updateBrandByEmail` mutation.
input UpdateBrandByEmailInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The brand’s primary email address.
  email: String!

  # An object where the defined keys will be set on the `Brand` identified by our unique key.
  brandPatch: BrandPatch!
}

# All input for the `updateBrandByName` mutation.
input UpdateBrandByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The brand’s human-readable name.
  name: String!

  # An object where the defined keys will be set on the `Brand` identified by our unique key.
  brandPatch: BrandPatch!
}

# All input for the `updateBrandByPhone` mutation.
input UpdateBrandByPhoneInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The brand’s phone number.
  phone: String!

  # An object where the defined keys will be set on the `Brand` identified by our unique key.
  brandPatch: BrandPatch!
}

# All input for the `updateBrandByRowId` mutation.
input UpdateBrandByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The unique identifier for the brand.
  rowId: Uuid!

  # An object where the defined keys will be set on the `Brand` identified by our unique key.
  brandPatch: BrandPatch!
}

# All input for the `updateBrand` mutation.
input UpdateBrandInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Brand` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `Brand` identified by our globally unique `ID`.
  brandPatch: BrandPatch!
}

# The output of our `updateBrand` mutation.
type UpdateBrandPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  brand: Brand

  # Reads a single `User` that is related to this `Brand`.
  userByOwnerId: User

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateChemicalChangeByName` mutation.
input UpdateChemicalChangeByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The human-readable name of the chemical change, e.x. cooked, baked, fermented, dehydrated.
  name: String!

  # An object where the defined keys will be set on the `ChemicalChange` identified by our unique key.
  chemicalChangePatch: ChemicalChangePatch!
}

# All input for the `updateChemicalChange` mutation.
input UpdateChemicalChangeInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `ChemicalChange` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `ChemicalChange` identified by our globally unique `ID`.
  chemicalChangePatch: ChemicalChangePatch!
}

# The output of our `updateChemicalChange` mutation.
type UpdateChemicalChangePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  chemicalChange: ChemicalChange

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateConversationByRowId` mutation.
input UpdateConversationByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The unique identifier for the conversation which is provided by the agent.
  rowId: Uuid!

  # An object where the defined keys will be set on the `Conversation` identified by our unique key.
  conversationPatch: ConversationPatch!
}

# All input for the `updateConversation` mutation.
input UpdateConversationInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Conversation` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `Conversation` identified by our globally unique `ID`.
  conversationPatch: ConversationPatch!
}

# The output of our `updateConversation` mutation.
type UpdateConversationPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  conversation: Conversation

  # Reads a single `User` that is related to this `Conversation`.
  userByUserId: User

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateFoodByRowId` mutation.
input UpdateFoodByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # 5-digit or 8-digit Nutrient Databank number that uniquely identifies a food item.
  rowId: Float!

  # An object where the defined keys will be set on the `Food` identified by our unique key.
  foodPatch: FoodPatch!
}

# All input for the `updateFoodGroupByRowId` mutation.
input UpdateFoodGroupByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # 4-digit code identifying a food group. Only the first 2 digits are currently assigned.
  rowId: Float!

  # An object where the defined keys will be set on the `FoodGroup` identified by our unique key.
  foodGroupPatch: FoodGroupPatch!
}

# All input for the `updateFoodGroup` mutation.
input UpdateFoodGroupInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `FoodGroup` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `FoodGroup` identified by our globally unique `ID`.
  foodGroupPatch: FoodGroupPatch!
}

# The output of our `updateFoodGroup` mutation.
type UpdateFoodGroupPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  foodGroup: FoodGroup

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateFood` mutation.
input UpdateFoodInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Food` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `Food` identified by our globally unique `ID`.
  foodPatch: FoodPatch!
}

# All input for the `updateFoodNutrientByFoodIdAndNutrientId` mutation.
input UpdateFoodNutrientByFoodIdAndNutrientIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # 5-digit or 8-digit Nutrient Databank number that uniquely identifies a food item.
  foodId: Float!

  # Unique 3-digit identifier code for a nutrient.
  nutrientId: Float!

  # An object where the defined keys will be set on the `FoodNutrient` identified by our unique key.
  foodNutrientPatch: FoodNutrientPatch!
}

# All input for the `updateFoodNutrient` mutation.
input UpdateFoodNutrientInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `FoodNutrient` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `FoodNutrient` identified by our globally unique `ID`.
  foodNutrientPatch: FoodNutrientPatch!
}

# The output of our `updateFoodNutrient` mutation.
type UpdateFoodNutrientPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  foodNutrient: FoodNutrient

  # Reads a single `Food` that is related to this `FoodNutrient`.
  foodByFoodId: Food

  # Reads a single `Nutrient` that is related to this `FoodNutrient`.
  nutrientByNutrientId: Nutrient

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# The output of our `updateFood` mutation.
type UpdateFoodPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  food: Food

  # Reads a single `FoodGroup` that is related to this `Food`.
  foodGroupByFoodGroupId: FoodGroup

  # Reads a single `Brand` that is related to this `Food`.
  brandByBrandName: Brand

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateFoodSelectionByRowId` mutation.
input UpdateFoodSelectionByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The food selection’s unique identifier.
  rowId: Uuid!

  # An object where the defined keys will be set on the `FoodSelection` identified by our unique key.
  foodSelectionPatch: FoodSelectionPatch!
}

# All input for the `updateFoodSelection` mutation.
input UpdateFoodSelectionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `FoodSelection` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `FoodSelection` identified by our globally unique `ID`.
  foodSelectionPatch: FoodSelectionPatch!
}

# The output of our `updateFoodSelection` mutation.
type UpdateFoodSelectionPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  foodSelection: FoodSelection

  # Reads a single `User` that is related to this `FoodSelection`.
  userByUserId: User

  # Reads a single `Conversation` that is related to this `FoodSelection`.
  conversationByConversationId: Conversation

  # Reads a single `Preset` that is related to this `FoodSelection`.
  presetByInheritsFromId: Preset

  # Reads a single `Place` that is related to this `FoodSelection`.
  placeByPlaceId: Place

  # Reads a single `Food` that is related to this `FoodSelection`.
  foodByFoodId: Food

  # Reads a single `Brand` that is related to this `FoodSelection`.
  brandByBrandId: Brand

  # Reads a single `ChemicalChange` that is related to this `FoodSelection`.
  chemicalChangeByChemicalChangeName: ChemicalChange

  # Reads a single `PhysicalChange` that is related to this `FoodSelection`.
  physicalChangeByPhysicalChangeName: PhysicalChange

  # Reads a single `UnitOfMeasure` that is related to this `FoodSelection`.
  unitOfMeasureByUnitOfMeasureId: UnitOfMeasure

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateMassConversionByFoodIdAndUnitOfMeasureIdAndPhysicalChangeName` mutation.
input UpdateMassConversionByFoodIdAndUnitOfMeasureIdAndPhysicalChangeNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The unique identifier for the food item.
  foodId: Float!

  # The unique identifier for the initial unit of measure which is a volume or count unit, e.x. liter, drumstick, piece, box.
  unitOfMeasureId: Int!

  # The unique name for the physical form or process the food is in.
  physicalChangeName: String!

  # An object where the defined keys will be set on the `MassConversion` identified by our unique key.
  massConversionPatch: MassConversionPatch!
}

# All input for the `updateMassConversionByRowId` mutation.
input UpdateMassConversionByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  rowId: Int!

  # An object where the defined keys will be set on the `MassConversion` identified by our unique key.
  massConversionPatch: MassConversionPatch!
}

# All input for the `updateMassConversion` mutation.
input UpdateMassConversionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `MassConversion` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `MassConversion` identified by our globally unique `ID`.
  massConversionPatch: MassConversionPatch!
}

# The output of our `updateMassConversion` mutation.
type UpdateMassConversionPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  massConversion: MassConversion

  # Reads a single `Food` that is related to this `MassConversion`.
  foodByFoodId: Food

  # Reads a single `UnitOfMeasure` that is related to this `MassConversion`.
  unitOfMeasureByUnitOfMeasureId: UnitOfMeasure

  # Reads a single `PhysicalChange` that is related to this `MassConversion`.
  physicalChangeByPhysicalChangeName: PhysicalChange

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateMessageByRowId` mutation.
input UpdateMessageByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The unique identifier for the message which is provided by the agent.
  rowId: Uuid!

  # An object where the defined keys will be set on the `Message` identified by our unique key.
  messagePatch: MessagePatch!
}

# All input for the `updateMessage` mutation.
input UpdateMessageInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Message` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `Message` identified by our globally unique `ID`.
  messagePatch: MessagePatch!
}

# The output of our `updateMessage` mutation.
type UpdateMessagePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  message: Message

  # Reads a single `Conversation` that is related to this `Message`.
  conversationByConversationId: Conversation

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateNutrientByRowId` mutation.
input UpdateNutrientByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # Unique 3-digit identifier code for a nutrient.
  rowId: Float!

  # An object where the defined keys will be set on the `Nutrient` identified by our unique key.
  nutrientPatch: NutrientPatch!
}

# All input for the `updateNutrient` mutation.
input UpdateNutrientInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Nutrient` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `Nutrient` identified by our globally unique `ID`.
  nutrientPatch: NutrientPatch!
}

# The output of our `updateNutrient` mutation.
type UpdateNutrientPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  nutrient: Nutrient

  # Reads a single `UnitOfMeasure` that is related to this `Nutrient`.
  unitOfMeasureByUnitOfMeasureUsdaKey: UnitOfMeasure

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updatePhysicalChangeByName` mutation.
input UpdatePhysicalChangeByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The human-readable name of the physical change, e.x. diced, farmers cut, blended, liquid.
  name: String!

  # An object where the defined keys will be set on the `PhysicalChange` identified by our unique key.
  physicalChangePatch: PhysicalChangePatch!
}

# All input for the `updatePhysicalChange` mutation.
input UpdatePhysicalChangeInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `PhysicalChange` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `PhysicalChange` identified by our globally unique `ID`.
  physicalChangePatch: PhysicalChangePatch!
}

# The output of our `updatePhysicalChange` mutation.
type UpdatePhysicalChangePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  physicalChange: PhysicalChange

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updatePlaceByName` mutation.
input UpdatePlaceByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The place’s human-readable name.
  name: String!

  # An object where the defined keys will be set on the `Place` identified by our unique key.
  placePatch: PlacePatch!
}

# All input for the `updatePlaceByRowId` mutation.
input UpdatePlaceByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The unique identifier for the place.
  rowId: Uuid!

  # An object where the defined keys will be set on the `Place` identified by our unique key.
  placePatch: PlacePatch!
}

# All input for the `updatePlace` mutation.
input UpdatePlaceInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Place` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `Place` identified by our globally unique `ID`.
  placePatch: PlacePatch!
}

# The output of our `updatePlace` mutation.
type UpdatePlacePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  place: Place

  # Reads a single `User` that is related to this `Place`.
  userByOwnerId: User

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updatePresetByRowId` mutation.
input UpdatePresetByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The unique identifier for the preset.
  rowId: Uuid!

  # An object where the defined keys will be set on the `Preset` identified by our unique key.
  presetPatch: PresetPatch!
}

# All input for the `updatePresetByUserIdAndName` mutation.
input UpdatePresetByUserIdAndNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The unique identifier for the person.
  userId: Uuid!

  # A name for the preset which is unique per user id so it can be conveniently referenced.
  name: String!

  # An object where the defined keys will be set on the `Preset` identified by our unique key.
  presetPatch: PresetPatch!
}

# All input for the `updatePreset` mutation.
input UpdatePresetInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Preset` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `Preset` identified by our globally unique `ID`.
  presetPatch: PresetPatch!
}

# The output of our `updatePreset` mutation.
type UpdatePresetPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  preset: Preset

  # Reads a single `User` that is related to this `Preset`.
  userByUserId: User

  # Reads a single `Conversation` that is related to this `Preset`.
  conversationByConversationId: Conversation

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updatePresetSelectionByPresetIdAndSelectionId` mutation.
input UpdatePresetSelectionByPresetIdAndSelectionIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The unique identifier for the preset.
  presetId: Uuid!

  # The unique identifier for the food selection.
  selectionId: Uuid!

  # An object where the defined keys will be set on the `PresetSelection` identified by our unique key.
  presetSelectionPatch: PresetSelectionPatch!
}

# All input for the `updatePresetSelection` mutation.
input UpdatePresetSelectionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `PresetSelection` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `PresetSelection` identified by our globally unique `ID`.
  presetSelectionPatch: PresetSelectionPatch!
}

# The output of our `updatePresetSelection` mutation.
type UpdatePresetSelectionPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  presetSelection: PresetSelection

  # Reads a single `Preset` that is related to this `PresetSelection`.
  presetByPresetId: Preset

  # Reads a single `FoodSelection` that is related to this `PresetSelection`.
  foodSelectionBySelectionId: FoodSelection

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateUnitOfMeasureByFullName` mutation.
input UpdateUnitOfMeasureByFullNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The full name of the unit of measure, e.x. cup, milliliter, gram, whole.
  fullName: String!

  # An object where the defined keys will be set on the `UnitOfMeasure` identified by our unique key.
  unitOfMeasurePatch: UnitOfMeasurePatch!
}

# All input for the `updateUnitOfMeasureByRowId` mutation.
input UpdateUnitOfMeasureByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The unique identifier for the unit of measure.
  rowId: Int!

  # An object where the defined keys will be set on the `UnitOfMeasure` identified by our unique key.
  unitOfMeasurePatch: UnitOfMeasurePatch!
}

# All input for the `updateUnitOfMeasureByShortName` mutation.
input UpdateUnitOfMeasureByShortNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The abbreviated or shortened name for the unit of measure, e.x. c, g, mg.
  shortName: String!

  # An object where the defined keys will be set on the `UnitOfMeasure` identified by our unique key.
  unitOfMeasurePatch: UnitOfMeasurePatch!
}

# All input for the `updateUnitOfMeasureByUsdaKey` mutation.
input UpdateUnitOfMeasureByUsdaKeyInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The original unique string from the USDA NDB for a unit of measure. Typos and
  # inconsistent plurals and abbreviations led to duplicated entries of the same
  # unit (e.x. cup, cups, and c). This column preserves those unique references.
  usdaKey: String!

  # An object where the defined keys will be set on the `UnitOfMeasure` identified by our unique key.
  unitOfMeasurePatch: UnitOfMeasurePatch!
}

# All input for the `updateUnitOfMeasure` mutation.
input UpdateUnitOfMeasureInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `UnitOfMeasure` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `UnitOfMeasure` identified by our globally unique `ID`.
  unitOfMeasurePatch: UnitOfMeasurePatch!
}

# The output of our `updateUnitOfMeasure` mutation.
type UpdateUnitOfMeasurePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  unitOfMeasure: UnitOfMeasure

  # Reads a single `UnitOfMeasure` that is related to this `UnitOfMeasure`.
  unitOfMeasureByShortNameRef: UnitOfMeasure

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateUserByPhone` mutation.
input UpdateUserByPhoneInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # A phone number. Phone numbers must be unique across all users and must match the E.164 numbering spec.
  phone: String!

  # An object where the defined keys will be set on the `User` identified by our unique key.
  userPatch: UserPatch!
}

# All input for the `updateUserByRowId` mutation.
input UpdateUserByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The user’s unique identifier.
  rowId: Uuid!

  # An object where the defined keys will be set on the `User` identified by our unique key.
  userPatch: UserPatch!
}

# All input for the `updateUser` mutation.
input UpdateUserInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `User` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `User` identified by our globally unique `ID`.
  userPatch: UserPatch!
}

# The output of our `updateUser` mutation.
type UpdateUserPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  user: User

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# A single human that uses the Terrafarm CSA app.
type User implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # The user’s unique identifier.
  rowId: Uuid!

  # A human-readable first and last name.
  name: String

  # A phone number. Phone numbers must be unique across all users and must match the E.164 numbering spec.
  phone: String!

  # A confidence rating from the geocoder.
  geoRating: Int

  # The geographical longitude of the user.
  lon: Float

  # The geographical latitude of the user.
  lat: Float

  # The geographical street number of the user.
  streetNumber: Int

  # The geographical street name of the user.
  streetName: String

  # The geographical street type of the user.
  streetType: String

  # The city of the user.
  city: String

  # The geographical state of the user.
  state: String

  # The zip code of the user.
  zip: String

  # The time this object was created.
  createdAt: Datetime

  # The time this object was last updated.
  updatedAt: Datetime

  # Reads and enables pagination through a set of `Conversation`.
  conversationsByUserId(
    # The method to use when ordering `Conversation`.
    orderBy: ConversationsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: ConversationCondition
  ): ConversationsConnection

  # Reads and enables pagination through a set of `Place`.
  placesByOwnerId(
    # The method to use when ordering `Place`.
    orderBy: PlacesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: PlaceCondition
  ): PlacesConnection

  # Reads and enables pagination through a set of `Brand`.
  brandsByOwnerId(
    # The method to use when ordering `Brand`.
    orderBy: BrandsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: BrandCondition
  ): BrandsConnection

  # Reads and enables pagination through a set of `Preset`.
  presetsByUserId(
    # The method to use when ordering `Preset`.
    orderBy: PresetsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: PresetCondition
  ): PresetsConnection

  # Reads and enables pagination through a set of `FoodSelection`.
  foodSelectionsByUserId(
    # The method to use when ordering `FoodSelection`.
    orderBy: FoodSelectionsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: FoodSelectionCondition
  ): FoodSelectionsConnection
}

# A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’
input UserCondition {
  # Checks for equality with the object’s `rowId` field.
  rowId: Uuid

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `phone` field.
  phone: String

  # Checks for equality with the object’s `geoRating` field.
  geoRating: Int

  # Checks for equality with the object’s `lon` field.
  lon: Float

  # Checks for equality with the object’s `lat` field.
  lat: Float

  # Checks for equality with the object’s `streetNumber` field.
  streetNumber: Int

  # Checks for equality with the object’s `streetName` field.
  streetName: String

  # Checks for equality with the object’s `streetType` field.
  streetType: String

  # Checks for equality with the object’s `city` field.
  city: String

  # Checks for equality with the object’s `state` field.
  state: String

  # Checks for equality with the object’s `zip` field.
  zip: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# A single human that uses the Terrafarm CSA app.
input UserInput {
  # The user’s unique identifier.
  rowId: Uuid

  # A human-readable first and last name.
  name: String

  # A phone number. Phone numbers must be unique across all users and must match the E.164 numbering spec.
  phone: String!

  # A confidence rating from the geocoder.
  geoRating: Int

  # The geographical longitude of the user.
  lon: Float

  # The geographical latitude of the user.
  lat: Float

  # The geographical street number of the user.
  streetNumber: Int

  # The geographical street name of the user.
  streetName: String

  # The geographical street type of the user.
  streetType: String

  # The city of the user.
  city: String

  # The geographical state of the user.
  state: String

  # The zip code of the user.
  zip: String

  # The time this object was created.
  createdAt: Datetime

  # The time this object was last updated.
  updatedAt: Datetime
}

# Represents an update to a `User`. Fields that are set will be updated.
input UserPatch {
  # The user’s unique identifier.
  rowId: Uuid

  # A human-readable first and last name.
  name: String

  # A phone number. Phone numbers must be unique across all users and must match the E.164 numbering spec.
  phone: String

  # A confidence rating from the geocoder.
  geoRating: Int

  # The geographical longitude of the user.
  lon: Float

  # The geographical latitude of the user.
  lat: Float

  # The geographical street number of the user.
  streetNumber: Int

  # The geographical street name of the user.
  streetName: String

  # The geographical street type of the user.
  streetType: String

  # The city of the user.
  city: String

  # The geographical state of the user.
  state: String

  # The zip code of the user.
  zip: String

  # The time this object was created.
  createdAt: Datetime

  # The time this object was last updated.
  updatedAt: Datetime
}

# A connection to a list of `User` values.
type UsersConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `User` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `User` and cursor to aid in pagination.
  edges: [UsersEdge]

  # A list of `User` objects.
  nodes: [User!]
}

# A `User` edge in the connection.
type UsersEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `User` at the end of the edge.
  node: User!
}

# Methods to use when ordering `User`.
enum UsersOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  PHONE_ASC
  PHONE_DESC
  GEO_RATING_ASC
  GEO_RATING_DESC
  LON_ASC
  LON_DESC
  LAT_ASC
  LAT_DESC
  STREET_NUMBER_ASC
  STREET_NUMBER_DESC
  STREET_NAME_ASC
  STREET_NAME_DESC
  STREET_TYPE_ASC
  STREET_TYPE_DESC
  CITY_ASC
  CITY_DESC
  STATE_ASC
  STATE_DESC
  ZIP_ASC
  ZIP_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

# A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122).
scalar Uuid
